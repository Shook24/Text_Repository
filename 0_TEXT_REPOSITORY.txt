STANDALONE DATA STORAGE WITHIN SEPARATE FILES
CHATGPT

How can I make a standalone python program that will write files to is own directory when running code that requires that?

To create a standalone Python program that writes files to its own directory, you can use the following steps:

Import the necessary modules: Start by importing the required modules, such as os and sys, which provide functions for working with directories and system-specific parameters.

> import os
> import sys

Determine the program's directory: Get the current directory path where the Python program is located. You can use sys.argv[0] to retrieve the program's file path and then os.path.dirname() to extract the directory.

> program_dir = os.path.dirname(sys.argv[0])

Create the full file path: Combine the program's directory with the desired filename to create the full file path.

> file_name = "output.txt"
> file_path = os.path.join(program_dir, file_name)

Write to the file: Use the file path obtained in the previous step to write data to the file.
python

> data = "Hello, world!"

	| with |
 
> open(file_path, "w") as file: 
	file.write(data)

Putting it all together, here's an example of a standalone Python program that writes a file to its own directory:

> import os
> import sys

	# Get the program's directory

> program_dir = os.path.dirname(sys.argv[0])

	# Create the full file path

> file_name = "output.txt"
  
	# Example filename

> file_path = os.path.join(program_dir, file_name)

	# Write to the file

> data = "Hello, world!"

	| with |
 
> open(file_path, "w") as file:
>    file.write(data)

When you run this program, it will create a file named "output.txt" in the same directory where the program is located and write the text "Hello, world!" to it. You can modify the file_name and data variables to suit your needs. 

HOW TO CLONE FROM GITHUB
- ' four lines ' -> ' Git ' -> ' clone... ' -> ' paste URL '

SYNC GITHUB AND PYCHARM
Ok, so I'm trying to figure out how to get Pycharm and Git to work together so that I can store my suite in GitHib and then download it on any computer from there to be worked on. This will be super useful when I start using different systems and I can continue projects from my main machine at home. So here is what ChatGPT Tells me to do:
Testing the changes here, it seems like it linked but I can't really tell from where I am now. Okay after fucking around for a bit what I've found it that you can put your files into the GitHub repository and then ' clone ' them into pycharm using the url and then you will have the project in the IDE but now I need to figure out how to add files in PyCharm and have them update in GitHub. Working on that now. This is really taking me all over the place. So now I'm thinking about the basic concept here and what I want to do is store all these files in a cloudspace that automatically updates when I make changes anywhere and I can run the updated files in PyCharm. It seems like GitHub is a bit too challenging for me but I'm starting to feel like I can use the GSuite as effectively as git hub but I have to come up with a new concept on how my files are organized. Right now it seems like files have a relationship with other to run so some ' program ' are feeding information to files that are outside of itself so when I'm designing program structures for the G Suite I have to keep in mind that the whole program has to fit in a folder and my concern there is dealing with output from various programs and pulling them into one another. So maybe what I need to do is start to modularize my programming and rely more on the input/output model of my programming so that what ever you do is with that concept of what does this program produce and output and is that output useful? Its really not clicking with me at the moment so I'm thinking I just need to find a GitHub Tutorial.
| HELLO WORLD | INTRODUCTION | Git

1. Set up a GitHub repository
2. Clone the repository to your local computer. I'm stuck on this step, it says ' Open pycharm on your computer and selec ' check out from version control ' on the welcome screen, or go to | ' VCS' -> ' Checkout ffom Version Control ' -> ' "Git" ' | if your already in PyCharm.

PERSONAL STUDIES
- A WHILE loops a FOR statement will only print once
' and '

- If a flash drive is saying that a file is too big too fit and there is enough space. Switch the format from FAT32 to NTFS.

[GOOGLE SHEETS WITH PYTHON]

TO LOAD FROM ANOTHER FILE
SHELL___
from saveytime.py import *

TERMINAL
' nothing here, this will load all the data from the file '

SAVING TO ANOTHER PYTHON FILE
SHELL___
needssavedone = 10
needssavedtwo = 20

(write or overwrite) - f = open('SavedThisFromAPythonFile_0328_1922.py','w')
(write and append) - f = open('SavedThisFromAPythonFile_0328_1922.py','a')
f.write('needssavedone = ' + str(needssavedone))
f.close

#this simply saves the string but below we will save the data

TERMINAL
C:\Users\khori\AppData\Local\Programs\Python\Python311\python.exe C:\Users\khori\Documents\PycharmProjects\SavingToPythonFile_0328_1921.py

Process finished with exit code 0

A PROGRAMMERS GUIDE TO MANAGING STRESS |_https://tinyurl.com/stress0324_|
I almost lost my mind because I wasn't taking care of it. Way too much crunch time for an important project, coupled with some ongoing issues in my personal life, pushed my ability to cope with day-to-day life into the red. Too many tickets. Not enough time. Lost, so very lost, in code. My heart raced. My mind raced. My ability to think clearly - so important when you're trying to get working software out the door, wen through the floor. I was super, super stressed. It effected everything, including how I felt, my relationships, my sleep and appetite, and especially my ability to do my job. It wasn't a good place - I was on the edge of somewhere nasty.

HIGH BLOOD PRESSURE SYMPTOMS AND CAUSES|_https://rb.gy/msv2_|
Blood pressure is the pressure of blood pushing against the walls of your arteries. Arteries carry blood from your heart to other parts of your body. Your blood pressure normally rises and falls throughout the day. WHAT DO BLOOD PRESSURE NUMBERS MEAN - Blood pressure is measured using two numbers: The first number called ' systolic ' blood pressure, measures the pressure in your arteries when your heart beats. The second number, called diastolic blood pressure, measure the pressure in your arteries when your heart rests between beats.If the measurement reads 120 systolic and 80 diastolic, you would say 120 over 80 or write 120/80

HYPERTENSION IN ATHLETES |_https://rb.gy/xprn_|
Hypertension is among the most common conditions seen in primary care and the most common cardiovascular condition affecting athletes. However, the management of hypertension in athletes can differ from standard approaches, primarily due to the potential side effects of some medications that may impair training and performance. The evaluation and management of athlete with hypertension will be review here. Standard management of hypertension will be reviewed here. Standard management of hypertension is discussed separately.

CHANGING OS COLORS |_https://tinyurl.com/2k2478k5_|
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
*An asterisk indicates I do not understand fully the concept being presented in that portion of the notes

A BYTE OF PYTHON STARTS AT 2441

NEEDS WORK
[] Understanding break and continue statements
[] 2230-2283
[] BITWISE OPERATORS


CHAPTER 1: PROGRAMMING BASICS AND STRINGS
INTERPRETED LANGUAGE - Meant that you are not going to need ot know a whole lot about computer hardware, memory, or long sequences of 0 and 1's 

"In real life, we ask people to do things, and sometimes we have to struggle mightily to ensure that our wishes are carried out"

PYTHON GOALS - To program in blocks that enable you to think about larger and larger projects by building each project as pieces that behave in well-understood ways. This is a key goal of a programming style known as ------------   object-oriented programming.

- I'm going to use Python in codespaces instead of using it in whatever the fuck they are talking about because I can use it for C as well.

- A data type in python, computers in general, and programming languages specifically, segregate everything they deal with into types. Types are categories for things within a program with which the program will work. After a thing has a type, the program ( and the computer ) knows what to do with that thing. This is a fundamental aspect of how computers work, because without a named type for the abstract ideas that they work with, the computer won't know how to do basic things like combine two different values. However, if you have two things, and they're of the same type, you can define easy rules for combining them. Therefore, when the type of a thing has been confirmed, Python knows what its options are, and you as the programmer know more about what to do with it. 

[X] STRINGS - The basic unit of text in Python
-------

p.6

- Unlike some other programming languages a single letter is represented as a one-letter string. When entering strings keep in mind the type of quotes (single or double) and the ends of lines.

ESCAPING - An ESCAPE CHARACTER is designated, and it has the power to remove the special significance from other special characters, such as quotes. This character in Python is the backslash (\)

- If you have to quote some text within a string and it uses the same style of quote in which you enclosed the entire string, you need to escape the quote that encloses the string to prevent Python from thinking that is has prematurely reach the end of a string. EXAMPLE:
	>>> 'And he said \ 'this string has escaped quotes\''
	
	
- I may have to use the software they referred to because codespaces is not running the code like the book says it will.

- Another problem here is that the wxPython.exe link is broken and I don't like the way the sites look. Super sketch but I did install python so maybe I'll return to codespaces and try to figure out how to run these strings through successfully. 

[X] TRIPLE QUOTE - Will almost always avoid the entire issue of requiring an escape character and will let you put in new lines as well. If you ever use a string enclosed in three quotes in a row, either single or double quotes, ------------   but all three have to be the same kind, then you do not have to worry about escaping any single instance of a single or double quote. Until Python sees three of the same quotes in a row, it won't consider the 	string ended, and it can save you the need to use escape characters in some situations.

[X] \n (newline) - Python will provide an interpretation to you in the interest of accuracy. The reason why \n may be more accurate than showing you the next character on a new line is twofold: First, that's one way for you to tell ------------   Python that you're interested in printing a new line, so it is not a one-way street. Second when displaying this kind of data, it can be confusing to actually be presented with a new line. Without the \n, you may not know whether something is on a new line because you've got a newline character or becausse there are spaces that lead up to the end of the line, and the display you're using has wrapped around past the end of the current line and is continued on the next line. By printing \n, Python shows you exactly what is happening. Within strings, Python has a way of representing special characters that you normally don't see, in fact, that may indicate an action, such as a newline, by using sequences of characters starting with a backlask (\).Remember that is's already special because its the escape character and now it's even more special. The newline is \n, and it is likely the most common special character you will encounter. Until you see hwo to print your strings, you'll see still see the escaped characters looking as you entered them, as \n, instead of, say, an actual line ending, with any more test starting on the line. 

[X] \t (indent) - Functions like newline but created and indent
-----------

+ - Allows you to combine strings like:
-	>>> "John" + "Wayne" + "sucks"
Combining strings this way will not add spaces.

- You can easily insert spaces between them, however. Like newlines, spaces are characters that are treated just liek any other character, such as A, s, d, or 5. Spaces are not removed from strings, even though they can't be seen
	>>> "John" + " " + "Q. " + " " + "Public"
	'John Q. Public'
	
PUTTING STRINGS TOGETHER IN DIFFERENT WAYS
[X] FORMAT SPECIFIER - Works by putting in a special sequence of charaters that Python will interepret as a placeholder for a value that will be provided by you. This may initially seem like it's too complex to be useful, but format
----------------   specifiers also enable you to control what the displayed information looks like, as well as a number of other useful tricks. EXAMPLE:

	>>> "John Q. %s" % ("Public)

				   The reason why this special escape sequence is called a format specifier is because you can do some other special things with it, that is, rather tha just insert values. You can provide somet specifications about how the values will be presented, how they'll look. 



_ I've run into a problem here where I need <stdin> and I can't figure out how to point to it at the moment, however I did find a Google guide for learning Python:
	https://developers.google.com/edu/python/set-up
  So I may just switch over to following that if the text is more consistent. 

GOOGLE FOR EDUCATION > PYTHON

- This is a bit too advanced for me, I just kinda glazed over it. 

- When I restarted Python and ran the program again it worked correctly. You might want to add that as a first means of troubleshooting if you've repeatedly checked the code is correct and it's still not working. 

[X] %s - Is the format specifier for a string. Several other specifiers will be described as their respective types are introduced. Each specifier acts as a placeholder for that type in the string; and after the string, the % sign 
--   outside of the string indicates that after it, all of the values to be inserted into the format specifier will be presented there to be used in the string. 

PARENTHESES - Indicate to the string that it should expect to see a sequence that contains the values to be used by the string to populate it's format
-----------

- Every format specification in a string has to have an element that matches it in the sequence that's provided to it. The items we are putting int the sequence are strings that are separated by commas (if there is more than one). If there is only one, as in the preceding example, the sequence isn't needed, but it can be used.

>>> "%s %s %10s" % ("John", "Q. ", "Public")
'John Q.      Public'
>>> "%-10s %s %10s" % ("John", "Q. ", "Public")
'John       Q.      Public'

HOW IT WORKS
FIRST STRING:
the reason why Public is so alone along the right side4 is because the third format specifier in the main string, on the left side, has been told to make room for something that has 10 charcters. That's what the %10s means. However, because the worf Public only has 6 characters, Python padded the string with space for the remaining four characters that is had reserved. 

SECOND STRING:
In the second string, the Q. is stranded in the middle, with John and Public far to either side. The behavior on it's right-hand side has just been explained. The behaviors on it's left happens for very similar reasons. An area with 10 spaces has been created in the string, but this string was specified with a %-10s. The - in the specifier means that the item should be pushed to the left, instead of to the right, as it normally would. 

[] DISPLAYING STRINGS WITH PRINT
Up until now you have seen how Python represents the strings you type, but only how it represents them internally. However, you haven't actually done anything that your program would show to a user. The point of the vast majority of programs is to present users with information - programs produce everything from sports stats to train schedules to web pages and automated telephone voice response units. The key point is that they all have to make sense to a person eventualy. 

PRINTING TEXT WITH PRINT
For displaying text, a special feature is built into useful languages, one that helps the programmer display information to users. The basic way to do this in Python is by using the print function:

[] ADDING SPACES BETWEEN STRING FORMAT SPECIFIERS 
>>> print("%s %s %10s" % ("John", "Q. ", "Public"))
John Q.      Public

- The book doesn't put parentheses around the Format Specifiers but without them the code won't run properly

You'll notice that there are no longer any quotes surrounding the first, middle and last name. In this case, it's significant - this is the first thing that you've done that would actually be seen by someone using a program that you've written. 

HOW IT WORKS
FUNCTION - A special name that you can put in your programs that will perform one or more tasks behind the scenes
--------

PRINT - Is an example of a built in function, which is a function included as a part of Python, as opposed to a function that you or another programmer has written. The print function performs output. 
-----

OUTPUT - It presents something to the user using a mechanism that they can see, such as a terminal, a window, a printer, or perhaps another device (such as a scrolling LED display).
------

INPUT - Such as gettin information from the user, from a file, from the network, and so on. Python considers these input/output (I/O) routines.
-----

I/O - commonly refers to anything in a program that prints, save, goes to or from a disk, or connects to a newwork.
---

CHAPTER 2: NUMBERS AND OPERATORS
NUMBERS IN PYTHON
- Python offers four different kinds of numbers with which you can work: intergers, long numbers (longs), floating-point numbers (floats), and imaginary numbers. 

INTEGERS AND LONGS - are very closely related and can be mixed freely. Each one is a whole number, positive or negative, but plain integers only run between -2,147,483,648 and +2,147,483,647. That's pretty big - big enough for alot of tasks. However, if you find that you need more than that, Python will notice this and automatically promote your number from a plain integer to a long number. 

Finished on page 14

[] TYPE - A special function that is built into Python, when you use TYPE, Python will tell you what kind of data 
----   you're looking at. Let's try this with a few examples:

>>> type(1)
<class 'int'>
>>> type(2000)
<class 'int'>
>>> type(print)
<class 'builtin_function_or_method'>
>>> type(print("hello world"))
hello world
<class 'NoneType'>

HOW IT WORKS 
[] %i INTEGER, REPRESENTED WITH A FORMAT SPECIFER FILLED AND PRINTED - Althout in everyday life 1.0 is the same number as 1, Python will automatically perceive 1.0 as being a float; without the .0, the number 1 would be --------------------------------------------------------------------   dealt with as the integer number one (which you probably learned as a whole number in school), which is a different kind of number.)

[] %f FLOATING POINT NUMBERS, REPRESENTED WITH A FORMAT SPECIFER FILLED AND PRINTED - Has a component that is a fraction of 1. Number such as 1.01, 2.34, 0.02324, and any other 
-----------------------------------------------------------------------------------   number that contains a fractional component is trated as a floating-point number. Thus us the type that you would want to use for dealing with money or with things deal with in patial quantities like gasoline or a pair of socks. 

'[number]j' IMAGINARY NUMBER, REPRESENTED WITH A FORMAT SPECIFER FILLED AND PRINTED, IF POSSIBLE - It is defined at the square root of -1. Despite being named imaginary it does have a lot of 
------------------------------------------------------------------------------------------------   practical uses in modeling real-world engineering situations, as well as in other diciplines like physics and pure math. The imaginary number is build into Python so that it's easily usable by user communities who frequently need to solve their problems with computers. Having this built-in type enables Python to help them do that. If you happen to be one of those people, you will be happy to learn that you're not alone, and Python is there for you. The imaginary number behaves very much like a float, except that it cannot be mixed with a float. When you see an imaginary number, it will have the letter 'j' trailing it:
	
	>>> 12j
	12j

[] My concept of this failed so I need to look into Imaginary Numbers more. Later on because I'm not really seeing anything that looks approachable on GeeksforGeeks and I want to stay on target and not rabbit hole. I think it's important to make this distiction so that I can know exactly when I choose to derail my tasks for rabbit holes. That has made my learning process fail in the past. 

Page 45/15 

HIGH-PRECISION FLOATING-POINT VALUES - For experts in engineering, financial, and other fields who deal with very large and very small numbers, small with a lot of decimal places, need even more accuracy and consistency 
---------------------------------------     than what build-in types like floats offer. If you're going to explore these disciplines within programming, you should use the available modules, a concept introduced in Chapter 7, which are written to handle the types of issues pertinent to the field in which you're interested. Or at least using modules that are written to handle high-precision floating-point values in a manner that is specifically different than the default behavior is worth investigating if you've got the need for them. 

[] PRINTING FLOATS TO EXACT DECIMAL POINTS

	SHELL
	LongFloat=2.565699596
	RoundedLongFloat = round(LongFloat, 2)
	print (RoundedLongFloat)

	LongFloat2=2.565699596
	RoundedLongFloat2 = round(LongFloat2, 5)
	print (RoundedLongFloat2)

	TERMINAL
	2.57
	2.5657
 
HOW IT WORKS
When you use the letter 'j' next to a number and outside the context of a string (that is, not enclosed in quotes), Python knows that you've asked it to treat the number you've just entered as an imaginary number. When any letter appearts outside of a string, it has to have a special meaning, such as this modifier, which specifies the type of number , or a named variable (which you'll see in Chapter 3), or another special name. Otherwise, the appearance of a letter by itself will cause an error!

You can combine imaginary and nonimaginary numbers to create complex numbers:
	
	>>> 12j + 1
	(1+12j)
	>>> 12j + 1.01
	(1.01+12j)
	>>> type (12j + 1)
	<class 'complex'>
	
You can see that when you try to mix imaginary numbers and other numbers, they are not added, subtracted, multiplied or divided. They're kept separate, in a way that creates a complex number. |

[] COMPLEX NUMBERS - have a real part and an imaginary part
   ---------------
   
	SHELL
	ComplexNumber=(12j+1)
	print (type(ComplexNumber))

	TERMINAL
	<class 'complex'>
	
USING THE SHELL WITH THE EDITOR
Enter the following in the Python shell window:

THE BOOK:
	>>> print “This is another string”
	This is another string
	>>> print “Joining two strings with “ + “the plus operation”
	Joining two strings with the plus operation
	>>> print “This is an example of including %s %s” % (“two strings”, “together”)
	This is an example of including two strings together
	
HOW I DID IT
	>>> print ("This is another string")
	This is another string
	>>> print ("joing two strings with " + "the plus operation")
	joing two strings with the plus operation
	>>> print ("This is an example of including %s %s" % ("two strings", "together"))
	This is an example of including two strings together
	>>> print ("I am combining dog and cat with %s %s" % ("dog", "cat"))
	I am combining dog and cat with dog cat
	
- The book wants me to use some kind of Python editor so I'm going to try the one that popped up on Google called IDLE, this was actually built into the Python 3.11 download I had just not been using the editor but the command line interface for Python which doesn't have a GUI

- Ok so in idle you can save your code and test it by running the code but in order for it to run correctly everything except the code from the command to the end of the syntax must be deleted so the save information looks like:
	
	print ("This is an example of including %s %s" % ("two strings", "together"))
	
- You will see that everything in quotes has been colored: this is codeEditor's way of indicating that this is a string, including where it begins and where it ends. 

USING THE DIFFERENT TYPES
 The numbers can grow to an unweildy number of digits to look at and make sense of. Therefore, very often when these numbers are generated, you will see them in a format that is similar to scientific notation. Python will let you input numbers in this format as well, so it's a two-way street. There are many snags to using vert large long integers and floats. The topic is quite detailed and not necessarily pertinent to learning Python. More commonly you will be using integers and floats. It wouldn't be unusual to acquire a number from somewhere such as the date, the time, or information about someone's age or the time of day. After tha data, in the form of a number, is acquired, you'll have to display it. The usual method is to incorporate numbers into STRINGS. You can use the format specifier method that was used already. Using the + method for including numbers into a string doesn't work because the + operator is intended for use only with two things of the same type: two strings, two numbers, or two other objects and types that you will encounter later. The definite exceptions are floats, longs, and integers can be added together. Otherwise, you should expect that different types won't be combined with the + operation. Compatible types should be thought of as the same type. You are likely wondering why a string format specifier (%s) can be used to include a number when a + can't. Let me try to include a number understanding what has been said so far:
 
	SHELL___
	print ("%s" % ("12"))
	
	TERMINAL 
	12
	
	SHELL___
	print ("%s" + "%s" % ("12", "13"))
	
	TERMINAL 
		Traceback (most recent call last):
		File "<pyshell#3>", line 1, in <module>
		print ("%s" + "%s" % ("12", "13"))
		TypeError: not all arguments converted during string formatting
	
	SHELL___
	print ("%s %s" % ("12", "13"))
	
	TERMINAL
	12 13
	
	SHELL___
	print ("12 + 13")
	
	TERMINAL
	12 + 13
	
I need a little refresher on what the '+' does:

+ - An operation that allows you to combine strings like:
-	>>> "John" + "Wayne" + "sucks", Combining strings this way will not add spaces. So I think it's saying I can add numbers by specifiying the number as a '%s' and adding it to another '%s' with the '+' and this will add the numbers together. It should look something like:

	SHELL___
		print ("%s + %s" % ("12", "13"))
	
	TERMINAL
		12 + 13
	
Well that's kind of what I was getting at but it didn't do the actual addition so lets just read on. You are likely wondering why a string format specifier (%s) can be used to include a number when a + can't. The reason is that the + operator relies on information contained in the actual items being added. Almost everything you use in Python can be though of as an object with properties, and all of the properties combined define the object. One important property of every object is it's type, and for now the important thing is to understand about a type is that certain naturally understood things like the '+' operation work only when you perform them with two objects of compatible types. In most cases, besides numbers, compatible types should be thought of as the same type. 

INCLUDING DIFFERENT NUMBERS IN STRINGS
You combined two strings in the first chapter by using a '%s' which means "a string". Because numbers ans strings have different types, you will use a different specifier that will enable your numbers to be included in a string:

[] %d (decimal integer inclusion) - %d is an integer inclusion that will accept decimal points, or floats and regular numbers. So like accept all numbers in all formats. ------------------------------   Including an integer works with %%d like this:

	
	print ("including an interger works with %%d like this: %d" % 10)
	including an interger works with %d like this: 10
	print ("including an integer works with %%d like this: %d" % 10)
	including an integer works with %d like this: 10
	print ("%%d is %d" % 10)
	%d is 10

- So it looks like %d can be included somewhere inside of "" and then refered to outside of the quotes by defining the percent like ("%d" % 10), lets try that simple one. 
	
	print ("%d" % 10)
	10

[] %f (float inclusion) - Including an integer converted to a float with %%f: %f % 5
--------------------

- It seems like %%f is working this way like %(s) = (%f)), like include a string but the string is a includes a float. so %%f means include a string that includes a float. lets try that:

	print ("%%f" % 10)
	Traceback (most recent call last):
	File "<pyshell#14>", line 1, in <module>
    print ("%%f" % 10)
	TypeError: not all arguments converted during string formatting
	
- I've gotten an error so I've done something wrong. I was expecting to get back 10, lets try it this way

	print ("%f" % 10)
	10.000000

- I think the issue here is I'm not really including a string called %f because there is not another part of a string for the escape charater '%' to escape from so I need to use something more like this:

	print ("so that the character can escape &&f" % 10)
	Traceback (most recent call last):
	File "<pyshell#16>", line 1, in <module>
    print ("so that the character can escape &&f" % 10)
	TypeError: not all arguments converted during string formatting
	
Hmm, another error let me replace '%%f' with '%f' and see what happens
	
	print ("so that the character can escapte &f" % 10)
	Traceback (most recent call last):
	File "<pyshell#17>", line 1, in <module>
    print ("so that the character can escapte &f" % 10)
	TypeError: not all arguments converted during string formatting
	
Okay I think the terminal is bugged so I'm going to restart it and try this code again: 

	print ("so that the character can escape &&f" % 10)
	Traceback (most recent call last):
	File "<pyshell#18>", line 1, in <module>
    print ("So that the character can escape %%f" % 10)
	TypeError: not all arguments converted during string formatting
	
Lol, to the issue above was that I was using ampersands instead of percentage signs but correcting that error occurs again. Closing whole window and reopening IDLE and trying again:

	print (" Let's try this again %%f" % 10)
	Traceback (most recent call last):
	File "<pyshell#0>", line 1, in <module>
    print (" Let's try this again %%f" % 10)
	TypeError: not all arguments converted during string formatting
	print ("lets try this again %f" % 10)
	lets try this again 10.000000
	
Okay, lesson learned here is that we never us &&f because it is stupid. 

And once again with an actual number with decimals:

	print ("with actual decimals %f" % 10.22563)
	with actual decimals 10.225630
	
Yo, that worked great! 

%E (Exponential Numbers, really large) - Including a really large integer specifying size with exponents
--------------------------------------

	print (" a large number called %E" % 6.789E10)
	a large number called 6.789000E+10
	
	print ("controlling the number of decimal places like %.02f" % 25.02020202)
	controlling the number of decimal places like 25.02
	
HOW IT WORKS
Anytime you are providing a format specifier to a string, there may be options that you can use to control how that specifier displays the value associated with it. ou've already seen this with the %s specifier in Chapter 1, where you could control how many characters were displayed. With numberic specifiers are also conventions regarding how the numbers of a particular type should be displayed. There conventions result in what you see when you use any of the numeric format specifiers.

ESACPING THE % SIGN IN STRINGS
One other trick was shown before, in case you wanted to print the literal string &d in your program, you acheive that in Python strings by using two %% together. This is only needed when you also have valid format specifiers that you want Python to substitute for you in the same string:
	
	print ("The %% behaves differently when combined with other letters, like this: %%d %%s %%f %d" % 10)
	The % behaves differently when combined with other letters, like this: %d %s %f 10
	
HOW IT WORKS
Note that Python pays attention to the combinations of letters and will behave correctly in a string that has both format specifiers as well as a double percent sign. 

BASIC MATH
It's more than not that you'll have to use the numbers in your program in basic math. Addition, subtraction, division, and multiplication are all build in. Addition and subtraction are preformed by the '+' and '-' symbols

DOING BASIC MATH
You can enter basic Math at the Python shell prompt and use it like a calculator. Like a calculator, Python will accept a set of operations, and when you hit the Enter key, it will evaluate everything you've typed and give you your answer:
	
	5 + 300
	305
	399+3020+1+3456
	6876
	300-59994+20
	-59674A
	4023-22.46
	4000.54
	
HOW IT WORKS
Simple math looks about how you'd expect it to look. In addition to + and -, multiplacation is performed by the asterisk, *, and division is performed by the forward slash /. Multiplaction and division may not be as straightforward as you'd expect in Python, because of the distinction between floating poin numbers and whole numbers. 
Also, you can see below that numbers will be automatically promoted at they become larger and larger - for instance, from integer to as long as needed:

	2000403030 * 392381727
	784921595607432810
	200040303030 * 3923817273929
	784921596511105678704870
	2e34 * 3923817273929
	7.847634547858e+46 - WHAT THE FUCK EVEN IS THAT 
	
Note that while Python can deal with some very large numbers, the results of some operations will exceed what Python can accomodate. The shorthand for infinity, inf, is what Python will return when a result is larger than waht it can handle. 

Division is also interesting. Without help, Python won't coax one kind of number into another through division. Only when you have at least one number that has a floating-point component, that is, a period followed by a number, will floating-point answers be displayed. If two numbers that are normal integers or longs (in either case, lacking a component that specifies a value less than one, even if that is .0) are divided, the remainder will be discarded. 

	44/11
	4.0
	324/101
	3.207920792079208
	324.0/101
	3.207920792079208
	
Looks like they've fixed this about Python since this book was written. 

USING THE MODULUS OPERATION
There is one other basic operation of Python that you should be aware of, the reamainder, or modulus operation. When you try to do division, liek the 324/101 in the preceding example, Python will return only the whole number portion of the result: the 3. To find out the rest of the answer, you have to use the module operator, which is the %. Don't let this confuse you, the % only means modulus only when it is used on numbers. When you are using strings, it retains it's meaning as the format specifier. When something has different meanings in different contexts, it is called overloading. and is very useful; but don't get caught by suprise when something behaves differently by design. 

	5/3
	1.6666666666666667
	5%3
	2

HOW IT WORKS
THe preceding code indicates that 5 divided by 3 is 1-2/3. One very useful task the modulus operator is used for is to discover whether one thing can be evenly divided by another, such as determining wheter the items in one sequence will fit into another evenly, here are some examples you can try out:

	5%3
	2
	123%44
	35
	334%13
	9
	652%4
	0
	
SOME SUPRISES
You need to be careful when you are dealing with common floating-point values, such as money. Some things in Python are puzzling. For on thing, if you manipulate certain numbers with seemingly straightforward math, you may still receive answers that have extra values trailing them, such as the following:

	4023-22.4
	4000.6
	
The trailing nines could worry you, but they merely reflect the very high precision that Python offers. However, when you print or perform math, this special feature actually results in precise answers

TRY IT OUT PRINTING THE RESULTS
Try actually printing the results, so that the preceding math with the unusual-looking results has it's results displayed to a user, as it would from inside of a program:

	print ("%f" % (4023 - 22.4)) [print ((a float) where that float is (4023 minus 22.4))]
	4000.600000
	
USING NUMBERS
You can display numbers with the print function by including the numbers into strings, for instance by using a format specifier. The important point is that you must determine how to display your numbers so that they mean what you intend them to mean, and that depends on knowing your application. 

ORDER OF EVALUATION 
When doing math, you may find yourself lookin at an expression like 4*3+1/4=12. The puzzle you're confronted with is determining how you're going to evaluate this sort of expression and whether the way you would evaluate it is the same way that Python would evaluate it. The safest way to do this is to always enclose your mathematical expressions in parentheses, which will make it clear which math operations will be evaluated first. 
Python evaluates these basic math operations as follows: Multiplacation and Division operations happen before addition and subtraction, but even this can become confusing.
 
 USING MATH OPERATIONS
 When you're thinking about a particular set of mathematical operatiosn, it can seem straightforward when you write it down. When you look at it later, however, it can become confusing. Try these examples, and imagine them without the parentheses. 
 
	(24*8)
	192
	(24*(8+3))
	264
	(24*(8+3+7))
	432
	(24*(8+3+7+9))
	648
	(24*(8+3+7+9))/19
	34.10526315789474
	(24*(8+3+7+9))/19
	34.10526315789474
	(24*(8+3+7+9))%19
	2
	
Notice in the examples here how the presence of any floaring-point numbers changes the entire equation to using floating-point numbers, and how removing any floating-point numbers will cause Python to evaluate everything as integers (or longs for larger numbers) 

HOW IT WORKS
The examples are grouped in something that resemble4s the normal order of operation, but the parentheses ensure that you can be certain which groups of Math operations will be evaulated first. The innermost (the most contained) are evaluated first, and the outermost last. Within a set of parentheses, the normal order takes place.

NUMBER FORMATS
WHen you prepare strings to contain a number, you have a lot of flexibility. For displaying money, use a formate specifier indicating that you want to limit the number of decimal places to two. 

TRY IT OUT USING NUMBER FORMATS 
	print ("$%.03f" % 30.00123)
	$30.001
	print ("$%.03f" % 30.00163)
	$30.002
	print ("$%.04f" % 30.00163)
	$30.0016
	print ("$.03f" % 30.1777)
		Traceback (most recent call last):
		File "<pyshell#11>", line 1, in <module>
		print ("$.03f" % 30.1777)
		TypeError: not all arguments converted during string formatting
	print ("$%.03f" % 30.1777)
	$30.178
	print ("$%.03f" % 30.1113)
	$30.111
	
As you can see, when you specify a format requiring more accuracy than you have asked Python to display, it will not just cut off the number, it will do the mathematically proper rounding for you as well. 

PAGE 53/22

MISTAKES WILL HAPPEN
While you are entering these examples, you may make a mistake. Obviosly, there is nothring that Python can do to help you if you enter a different numbers: you will get a different answer than the one in this book. However, for msitakes such as entering a letter as a format specifier that doesn't mean anything to Python or not providing enough numbers in a sequence you're providing to a string's format specifiers, Python tries to give you as much information as possible to indicate what's happened so that you can fix it. 

MAKING MISTAKES
To understand what's going on when a mistake happens, here are some examples you can try. Their full means are covered later, starting in Chapter 4, but in the meantime, you should know this. 

	print ("%.03f" % (30.1113, 12))
	Traceback (most recent call last):
	File "<pyshell#1>", line 1, in <module>
    print ("%.03f" % (30.1113, 12))
	TypeError: not all arguments converted during string formatting
	
HOW IT WORKS
In the preceding code, there are more elements in the sequence (three in all) than there are in format specifiers in the string (just two), so Python helps you out with a message. What's less helpful is that this mistake would cause a running program to stop running, so this is normally an error condition, or an EXCEPTION. The term ARGUMENTS here refers to the format specifiers but it generally used to mean parameters that are required in order for some objects to work. When you call a function that expects a certain number of values to be specified, each one of those anticipated values is called an argument. 

ARGUMENT - WHen you call a function that expects a certain number of values to be specified, each one of those anticipated values is called and argument
--------

EXCEPTION - An error condition, or a mistake that would cause a program to stop running. 
---------

his is something that programmers take for granted: this specialized technical language may not make sense immediately, but it will begin to feel right when you get used to it. Through the first ten chapters of this book, arguments will be referred to as PARAMETERS to make them less puzzling, since no one is arguing, just setting the conditions that are being used as a particular point in time. When you are programming, though, the terms are interchangable. 

PARAMATERS - What ARGUMENTS will be referred to for the first 10 chapters of this book 
----------

Here is another potential mistake:

	print ("%.03f, %f %d" % (30.1113, 12))
		Traceback (most recent call last):
		File "<pyshell#3>", line 1, in <module>
		print ("%.03f, %f %d" % (30.1113, 12))
		TypeError: not enough arguments for format string
	
You have a format specifier, and you don't have a value in the accompanying sequence that makes in the accompanying sequence that matches it, thus, there arent enough parameters.

If you try to perform addition with a string and a number, you will aslo get an error:

	"this is a string" + 4
		Traceback (most recent call last):
		File "<pyshell#4>", line 1, in <module>
		"this is a string" + 4
		TypeError: can only concatenate str (not "int") to str
		
Python is telling you clearly that is can't do what it has been asked to do, so now it's up to you to resolve the situation, use string.

SOME UNUSUAL CASES
There is one other feature that Python offers with it's numbers that is worth knowing about so that you understand it when you encounter it. The normal counting system that we use is called base 10, or radix 10. Computers commonly represent the binary numbers they actually deal with in base 8, octal and base 16, hexadecimal. These systems are often used to give programmers an easier way to understand bytes of data, which often come in one and two chunks of 8 bits

Neither octal nor hexadecimal can be displayed as negative numbers, Numbers described in this way are said to be unsigned. As opposed to being signed. The sign that is different is the + or - sign. Normally, numbers are assumed to be positive, but if a number is a signed type, it can be negative as well. If a number is unsigned, it has to be positive: and if you ask for the display of a negative number but in a signed format string, you'll get unusual answers.

UNSIGNED - Number systems that can't be displayed as negative
--------

FORMATTING NUMBERS AS OCTAL AND HEXADECIMAL

	print ('Octal uses the letter "o" lowercase. %d %o' % (10, 10))
		Octal uses the letter "o" lowercase. 10 12
		
It may seem like a mistake that the second number printed is 12 when you've provided the string with a 10. However, octal only has 8 numbers (0-7), so from 0 to 10 in octal is 0,1,2,3,4,5,6,7,8,10,11.

'OCTAL' - It seems a octal has to be specified like this '<0o>4' in order to tell the computer there is a zero before the four, it appears the zero won't show up when printed or called so I'm not really sure what the point is. 
---------

	print ('hex uses the letter "x" or "X". %d %x %X' % (10,10,10))
		hex uses the letter "x" or "X". 10 a A

Here is another case that needs explaining. Hexadecimal uses numbers from 0 to 15, but because you run out of numbers at 9, hex utilizes the letters a-f; and the letters are lowercase if you used the format specifier %x and is capitalized if you used %X. Therefore, the numbers 0 to 20 in decimal are as follows in hex:0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,12,13

The format, or how the number is displayed in a string, doesn't change the value of the number. Floats remain floats even when they are printed as integers, and longs remain longs even when they are printed as floats.

- Longs don't have a format specifier, it seems that Python will automatically convert a integer to a long if the number is long enough to need conversion.

%u Unicode - Is a way for a string to represent more characters than a regular ASCII string can. 
----------

\t TAB - Will indent the line following \n
------

\n NEW LINE - Will create a new line and this can be seen when printing the string
-----------

CHAPTER 3: VARIABLES - NAMES FOR VALUES

In the previous two chapters, you learned how Python views strings, integers, longs, floats, and imaginary numbers and how they can be created and displayed. This chapter presents more examples that will demonstrate how these data types can be used. 

 In this chapter, you will learn how to use names to store the types you already know as well as other basic types to which you will be introduced. The same facility will enable you to work with different types of objects that you haven't learned about yet, too. By the end of this chapter, you should be familiar with variable and new different types - specifically, you will become better acquainted with lists, tuples, and dictionaries. You will know what a reference is and have some experience in using references. 
 
 To get the most out of this chapter, you should type the examples yourself and alter them to see what happens. 

 REFERRING TO DATA - USING NAMES FOR DATA
 
 It's difficult to always write strings and numbers explicitly throughout a program because it forces you to remember everything. The exacting memory that computers have enable them to remember far more details than people can, and taking advantage of that capability is a huge part of programming. However, to make using data more flexible and easy, you want to five the data names that can be used to refer to them. 
 
 TRY IT OUT: ASSIGNING VALUES TO NAMES
 VARIABLES - Indicates that the data to which they refer can vary, while the name remains the same. You'll see them referred to as NAMES as well, because that is what you are presented with by Python. 
 ---------
 
	print ("the first variables are %s, %s, %d, %d" % (first_string, second_string, first_number, second_number))
		the first variables are This is a string, This is another string, 4, 5
 
 HOW IT WORKS
 You can see that you can associate a name with a value - either a string or an integer - by using the '=' sign. The name that you use doesn't relate to the data to which it point in any direct sense (that is, if you name it "number," that doesn't actually have to mean that it holds a number.)
 
	first_string = 245
	second_number =
		SyntaxError: incomplete input
	second_number = "this isn't a number"
	first_string
		245
	second_number
		"this isn't a number"
		
The benefit of being able to name your data is that you can decide to give it a name that means something. It is always worthwhile to give your data a name that reminds you of what it contains or how you will use it in your program. If you were to inventory the lightbulbs in your home, you might want a piece of your program to contain a count of the lightbulbs in your closets and another piece to contain a count of those actually in use:

	lightbulbs_in_closet = 10
	lightbulbs_in_lamps = 12
	
As lightbulbs are used, they can be moved from the closet into the lamps, and a name can be given to the number of lightbulbs that have been thrown out this year, so that at the end of the year you have an idea of what you've bought, what you have, and what you've used; and when you want to know what you still have, you have only to refer to lightbulbs_in_closet or lightbulbs_in_lamps.

When you have names that relate to the value stored in them, you've created an informal index that enables you to look up and remember where you put the information that you want so that is can be easily used in your program.

CHANGING DATA THROUGH NAMES
If your data is a number or a string, you can change it by using the operations you already know you can do with them. 

TRY IT OUT: ALTERING NAMED VALUES
Every operation you've learned for numbers and strings can be used with a variable name so that you can treat them exactly as if they we're the numbers they referenced:

	proverb = "A penny saved"
	proverb = proverb + " is a penny earned"
	print proverb
		SyntaxError: incomplete input
	print (proverb)
		A penny saved is a penny earned
	pennies_saved = 0
	pennies_saved = pennies_saved + 1
	pennies_saved
		1
		
			? When a variable is named does it type have to match the type of another named variable for math to be used like a %s to %s to a %i to an %i?

HOW IT WORKS
WHenever you combine named values on the right-hand side of an '=' sign, the names will be operated on as though you had presented Python with the values referenced by the names, even if the same name is on the left-handside of the = sign. When Python encounters a situation like that, it will first evaluate and find the result of the operations on the right side and then assign the result to the name on the left side. That way, there's no confusion about how the name can exist on both side. That way, there's no confusion about how the name can exist on both sides - Python will do the right thing. 

COPYING DATA
THe name that you five data is only a name. It's how you refer to that data that you're trying to access. This means that more than one name can refer to the same data:

	proverb = "A penny saved"
	proverb = proverb + " is a penny earned"
	print (proverb)
		A penny saved is a penny earned
	pennies_saved = 0
	pennies_saved = pennies_saved + 1
	pennies_saved
		1
	pennies_earned = pennies_saved
	pennies_earned
		1

When you use the = sign again, you are referring your name to a new value that you've created, and the old value will still be pointed to by the other name:

	pennies_saved = pennies_saved + 1
	pennies_saved
		2
	pennies_earned
		1
		
NAMES YOU CANT USE AND SOME RULES
Python uses a few names as special built-in words that it reserves for special use to prevent ambiguity. The following words are reserved by Python and can't be used as the names for data
	
	and
	asset
	break
	ckass
	continue
	def
	del
	elif
	else
	except 
	exec
	finally
	for
	from
	global
	if
	import
	in
	is
	lambda
	not
	or
	pass
	print
	raise
	return
	try
	while
	yield
	
In addition, the names for data cannot begin with numbers or most non-alphabet characters (such as commas, plus or minus, slashes, and so on), with the exception of the underscore character. The underscore is allowed and even has a special meaning in some cases.

USING MORE BUILT-IN TYPES
Besides strings and numbers, Python provides three other important basic types: tuples, lists, and dictionaries. These three types have a lot in common because they all allow you to group more that one item of data together under one name. Each on also give you the capability to search through them because of that grouping. These groupings are indicated by the presence of enclosing parentheses '()', square brackets '[]' and curly braces '{}'.
WHen you write a program, or read someone else's program, it is important to pay attention to the type of enclosing braces when you see groupings of elements. The differences among {},[], and () are important. 

'()' | TUPLES - UNCHANGING SEQUENCES OF DATA
In chapters 1 and 2, you saw tuples (rhymes with supple) being used when you wanted to assign values to match more than one format specifier in a string. Tuples are a sequence of values, each one accessible individually, and a tuple is a basic type in Python. You can recognize tuples when they are created because they are surrounded by parentheses and are immutable because they are supposed to be used for ordered groups of things that will not be changed while you're using them. is a sequence of data that’s indexed in a fixed numeric order, starting at zero. The references in the tuple can’t be changed after the tuple is created. Nor can it have elements added or deleted. However,if a tuple contains a data type that has changeable elements, such as a list, the elements of that data type are not prevented from changing. Tuples are useful when the data in the sequence is better off not changing, such as when you want to explicitly prevent data from being accidentally changed.

	print ("A %s %s %s %s" % ("string", "filled", "by a", "tuple"))
		A string filled by a tuple
		
TRY IT OUT: CREATING AND USING A TUPLE
Tuples contain references to data such as strings and numbers. However, even though they refer to data, the can be given names just like any other kind of data. 

	filler = ("string", "filled", "by a", "tuple")
	print ("A %s %s %s %s" % filler)
		A string filled by a tuple
		
HOW IT WORKS
You can see in the example that 'filler' is treated exactly as though it's data - the tuple with strings - were present and being used by the string to fill in its format specifiers because the tuple was treated exactly as though you had typed in a sequence to satisfy the format specification. You can access a single value inside of a tuple. The value referref to by each element can be accessed directly by using the dereference feature of the language. With tuples, you dereference the value by placing square brackets after the name of the tuple, counting from zero to the element that you're accessing. Therefore, the first element is 0, and the second element is 1, the third element is 2 and so until you reach the last element of the tuple

	a = ("first", "second", "third")
	print ("the first element of the tuple is %s" % a[0])
		the first element of the tuple is first
	print ("the second element of the tuple is %s" % a[1])
		the second element of the tuple is second
	print ("the third element of the tuple is %s" % a[2])
		the third element of the tuple is third

A tuple keeps track of how many element it contains, and it can tell you when you ask it by using the built-in function len

' len ' (Length of an...) - Tells you how many elements are in a tuple, prints the number of elements in a tuple
-------------------------

	print ("%d" % len(a))
		3
		
You can also have one element of a tuple refer to an entirely different tuple. In other words, you can create layers of tuples:

	b = (a, "b's second element")

Now you can access the elements of the tuple 'a' by adding another set of brackets after the first one, and the method for accessing the second element is no different from accessing the first - you just add another set of square brackets. 

TRY IT OUT: ACCESS A TUPLE THROUGH ANOTHER TUPLE
Recreate the a and b tuples so that you can look at how this works. When you have these layers of sequences, they are sometimes referred to as multidimenional because there are two layers that can be visualized as going down and across, like a two-dimentional grid for graph paper or a spreadsheet. Adding another can be though of as being three-dimensional, like a stack of blocks. Beyond that, theough, visualizing this can give you a headache, and it's better to look at is as layers of data. 

	a = ("first", "second", "third")
	b = (a, "b's second element")
	print ("%s" % b[1])
		b's second element
	print ("%s" % b[0][0])
		first
	print ("%s" % b[0][1])
		second
	print ("%s" % b[0][2])
		third
	type (b)
		<class 'tuple'>
		
HOW IT WORKS
In each case, the code works exactly as though you had followed the reference in the first element of the tuple named 'b' and then followed the references for each value in the second later tuple what originally can from the tuple 'a'. It's as though you had done the following. 

	a = ("first", "second", "third")
	b = (a, "b's second element")
	layer2[0]
		Traceback (most recent call last):
		File "<pyshell#36>", line 1, in <module>
    layer2[0]
		NameError: name 'layer2' is not defined
	layer2 = b[0]
	layer2[0]
		'first'
	layer2[1]
		'second'
	layer2[2]
		'third'
	b[1]
		"b's second element"
	b[0][0]
		'first'
	b[0][1]
		'second'
	b[0][2]
		'third'
		
Note that tuples have one oddity when they are created: to create a tuple with one element, you absolutely have to follow that one element with a comma:

	single_element_tuple = ("the sole element",)

Doing otherwise will result in the creation of a string, and that could be confusing when you go to access it later. A tuple can have any kind of data in it, but after you've created one it can't be changed. It is immutable, and in Python this is true for a few types (for instance, strings are immutable after they are created: and operations on them that look like they change them actually create new strings). Tuple are immutable because they are supposed to be used for ordered groups of things that will not be changed while you're using them. Trying to change anything in them will cause Python to complain with an error, similar to the errors you we're shown at the end of Chapter 2:

	a[1] = 3
		Traceback (most recent call last):
		File "<pyshell#47>", line 1, in <module>
			a[1] = 3
		TypeError: 'tuple' object does not support item assignment
	print ("%s" % a[1])
		second

You can see that the error Python returns when you try to assign a value to an element in the tuple is a TypeError, which means that this type doesn't support the operation you asked it to do, thats what the equals sign does - it asks the tuple to perform an action. In this case, you were trying to get the second element in 'a' to refer to an integer, the number 3, but thats not going to happen. Instead, 'a' remains unchanged. An unrelated error will happen if you try to refer to an element in a tuple that doesn't exist. If you try to refer to a fourth element in a, you will get an error. remember that because tuples start counting their elements at zero and the fourth element should be represented by the number three. 

TypeError - Means that this tupe doesn't support the operation you asked it to do
---------

	a[3]
		Traceback (most recent call last):
		File "<pyshell#50>", line 1, in <module>
		a[3]
		IndexError: tuple index out of range
		
Note that this is an IndexError and that the explaination fo the error is provided although it doesn't tell you what the index value that was out of range was, you do know that you tried to access an element using an index value that doesn't exist in the tuple. To fix this in a program, you would have to find out what value you were trying to access and how many elements are in the tuple. Python makes finding these errors relatevely simple compared to many other languages that will fail silently.

LISTS-CHANGEABLE SEQUENCES OF DATA
'[]' LISTS - like tuples, are sequences that contain elements referenced starting at zero. Lists are create by using square brackets. Most often, this is done in a loop to view every element in a sequence. The primary ---------    difference in using a list versus using a tuple is that a list can be modified after it has been created. The list can be changed at any time. is another type of sequence, which is similar to a tuple except that its elements can be modified. The length of the list can be modified to accommodate elements being added using the append method, and the length can be reduced by using the pop method. If you have a sequence whose data you want to append to a list, you can append it all at once with the extend method of a list.

	breakfast = ["coffee", "tea", "toast", "egg"]
	
TRY IT OUT: VIEWING THE ELEMENTS OF A LIST 
	The individual elements of a list can be accessed in the same way as tuples. Like tuples, the elements in a list are referenced starting at 0 and are access in the same order from zero until the end. 

	count = 0
	breakfast = ["coffee","tea","toast","egg"]
	count = 0
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is coffee
	count = 1
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is tea
	count = 2
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is toast
	count = 3
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is egg
		
HOW IT WORKS
When you are accessing more tha one element of a list, one after the other, it is essential to use a name to hold the value of then numbered position where you are in the list. In simple examples like this, you should do it to get used to the practice, but in practice, you will always do this. Most often, this is done in a loop to view every element in a sequence. Here you're manually doing the work of increasing the value referred to by count to go through each element in the breakfast list to pull out the special for four days of the week. Because you're increasing the count, whatever number is referred to by count is the element number in the breakfast list that is accessed. The primary difference in using a list versus using a tuple is that a list can be modified after it has been created. The list can be changed at any time. 

- The difference between tuple and list is that tuples are immutable and list can be changed at any time. 

	breakfast[count] = "sausages"
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is sausages
	
	- I'm confused on what [count] is doing here. it seems like we are setting "sausages" equal to 'breakfast[count]' as if it we're a name of the string "sausages"
	
You don't just have to change elements that already exist in the list, you can also add elements to the list as you need them. You can add elements at the end by using the APPEND method that is build in to the list type. Using APPEND enables you to append exactly one item to the end of a list:

[listname].append("[listaddition]") (APPEND) - Allows you to add exactly one item to the end of a list
--------------------------------------------

	newlist = ["one", "two", "three", "four"]
	newlist
		['one', 'two', 'three', 'four']
	newlist.append("five")
	newlist
		['one', 'two', 'three', 'four', 'five']

	breakfast.append("waffle")
	count = 4
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is waffle
	count = 3
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is sausages
	breakfast
		['coffee', 'tea', 'toast', 'sausages', 'waffle']
		
If you wanted to add more than one item to the end of a list - for instance, the contents of a tuple or of another list - you can use the EXTEND method to append the contents of a list all at once. The list isn't included as one tme in one slot: each element is copied from one list to the other.

[listname].extend(["[item]", "[item]", "[item]"]) (EXTEND) - Allows you to add multiple items to a list all at once. 
----------------------------------------------------------  
	
	breakfast.extend(["juice", "decaf", "oatmeal"])
	breakfast
		['coffee', 'tea', 'toast', 'sausages', 'waffle', 'juice', 'decaf', 'oatmeal']
		
As with tuples, you can't ask for an element beyond the end of a list, but the error message is slightly differnt from a tuple because the error will tell you that is's a list index that is out of range, instead of a tuple index that is out of range:

	count=5
	print ("todays breakfast is %s" % breakfast[count])
		todays breakfast is juice
	count=8
	print ("todays breakfast is %s" % breakfast[count])
		Traceback (most recent call last):
		File "<pyshell#30>", line 1, in <module>
		print ("todays breakfast is %s" % breakfast[count])
		IndexError: list index out of range

The length of an array can also be determined by using the LEN function. Just like tuples, lengths start at one, whereas the first element of a list starts at zero. It's important to always remember this. 

'{}' (DICTIONARIES) - GROUPINGS OF DATA INDEXED BY NAME -is similar to lists and tuples. It's another type of container for a group of data. However, whereas tuples and lists are indexed by their numeric order, dictionaries are -------------------   indexed by names that you choose. These names can be letters, numbers, strings, or symbols - whatever suits you. When you first assign to MENUS_SPECIAL, you're creating an empty dictionary with the curly braces. Are yet another kind of indexed grouping of data. List and tuples are indexed by numbers, dictionaries are indexed by values that you choose. To explore the indexes, which are called keys, you can invoke the keys method. To explore the data that is referred to, called the values, you can use the values method. Both of these methods return lists. 

TRY IT OUT: MAKING A DICTIONARY
Dictionaries are created using the curly braces. To start with, you can creat the simplest dictionary, which is an empty dictionary, and populate it using names and values that you specify one per line:
	
	menus_specials = {}
	menus_specials["breakfast"] = "canadian ham"
	menus_specials["lunch"] = "tuna surprise"
	menus_specials["dinner'] = "Cheeseburger Deluxe"
               
		SyntaxError: unterminated string literal (detected at line 1)
	menus_specials["dinner"] = "Cheeseburger Deluxe"
	menus_specials
		{'breakfast': 'canadian ham', 'lunch': 'tuna surprise', 'dinner': 'Cheeseburger Deluxe'}
		
PAGE 64/34

HOW IT WORKS 
When you first assign to MENUS_SPECIAL, you're creating an empty dictionary with the curly braces. Once the dictionary is defined and referenced by the name, you may start to use this style of specifying the name that you want to be the index as the value inside of the square brackets, and the values that will be referenced through that index are on the right side of the equals sign. Because they're indexed by names that you choose, you can use this form to assign indexed and values to the contents of any dictionary that's already been defined. When you're using dictionaries, there are special names for the indexes and values. Index names in dictionaries are called keys, and the values are called wel, values. To create a fully specified (or you can think of it as a completely formed) dictionary - one with keys and values assigned at the outset - you have to specify each key and it's corresponding value, separated by a colon, between the curly braces. For example, a different day's specials could be difined all at once.

	menu_specials = {"breakfast":"sausage and eggs", "lunch":"split pea soup and garlic bread", "dinner":"2 hot dog and onion rings"}
	menu_specials
		{'breakfast': 'sausage and eggs', 'lunch': 'split pea soup and garlic bread', 'dinner': '2 hot dog and onion rings'}
		
To access any of the values, you use square brackets with the name of the key enclosed in the brackets. If they key is a string, the key has to be eclosed in quotes. If the key is a number (you can use numbers, too, maing a dictionary look a lot like a list of a tuple), you need only the bare number

	print ("%s" % menu_specials["breakfast"])
		sausage and eggs
	print("%s"%menu_specials["lunch"])
		split pea soup and garlic bread
	print("%s"%menu_specials["dinner"])
		2 hot dog and onion rings

If a key that is a string is accidentally not enclosed in ruotes when you try to use it within square brackets, python will stry to treat it as a name that should be dereferenced to find the key. In most cases, this will raise an excpetion - a NameError - unless it happens to find a name that is the same as the string, in which case you will probably get an IndexError from the dicationary instead.

TRY IT OUT: GETTING THE KEYS FROM A DICTIONARY 
Dictionaries can tell you what all of their keys are, or what all of their values are, if you know how to ask them. The keys method will ask the dicationary to return all of it's keys to you as a list so that you can examine them for the key or keys you are looking for, and the vaules method will return all of the values as a list.

	menu_specials.keys()
		dict_keys(['breakfast', 'lunch', 'dinner'])
	menu_specials.vales()
		Traceback (most recent call last):
		File "<pyshell#7>", line 1, in <module>
		menu_specials.vales()
		AttributeError: 'dict' object has no attribute 'vales'. Did you mean: 'values'?
	menu_specials.values()
		dict_values(['sausage and eggs', 'split pea soup and garlic bread', '2 hot dog and onion rings'])
		menu_specialse.keys().values()
		Traceback (most recent call last):
		File "<pyshell#9>", line 1, in <module>
    menu_specialse.keys().values()
		NameError: name 'menu_specialse' is not defined. Did you mean: 'menu_specials'?
	menu_specials
		{'breakfast': 'sausage and eggs', 'lunch': 'split pea soup and garlic bread', 'dinner': '2 hot dog and onion rings'}		

HOW IT WORKS
Both the keys and values methods return lists, which you can assign and use like any normal list. When you have the items in a list from the keys method, you can use the items in the list, which are keys, to get their matching values from that dictionary. Note that while a particular key will lead you to a value; you need to exhasutively test all the possible keys to find a matching value and even then, two different keys can have the same values associated with them. In addition, the way that dictionaries work is that each key is different ( you can't have two keys that are exactly the same ), but you can have multiple duplicate values.

	THE BOOK
	count = 0
	specials_keys = menu_specials.keys()
	print (“%s is the key, and %s is the value” % (specials_keys[count],menu_specials[specials_keys[count]]))
		lunch is the key, and split pea soup and garlic bread is the value
	count = 1
	print (“%s is the key, and %s is the value” % (specials_keys[count],menu_specials[specials_keys[count]]))
		breakfast is the key, and sausage and eggs is the value
	count = 2
	print “%s is the key, and %s is the value” % (specials_keys[count], menu_specials[specials_keys[count]]))
		dinner is the key, and 2 hot dogs and onion rings is the value
		
	MY TERMINAL
	count = 0
	special_keys=menu_specials.keys()
	print ("%s is the key, and %s is the value" % (special_keys[count],menu_specials[special_keys[count]]))
		Traceback (most recent call last):
		File "<pyshell#14>", line 1, in <module>
		print ("%s is the key, and %s is the value" % (special_keys[count],menu_specials[special_keys[count]]))
		TypeError: 'dict_keys' object is not subscriptable
	special_keys[count]
		Traceback (most recent call last):
		File "<pyshell#15>", line 1, in <module>
		special_keys[count]
		TypeError: 'dict_keys' object is not subscriptable

- So in my terminal its saying that dictionary key can not be subscriptable lets define that words

SUBSCRIPTABLE - an object that can contain other objects, the objects which are containers can be termed as subscriptable 
-------------   objects. Strings, Tuples, Lists and Dictionaries are examples of subscriptable objects in Python. 

- Okay so I've googles "dictionary keys are not subscriptable python" in google and I've got a website that says this:

	'The Python "TypeError: 'dict_keys' object is not subscriptatble" occues when we try to access a dict_keys object as a specific INDEX'
	
- So let me define INDEX as well and maybe we can get a clearer understanding of the issue. 

INDEX - refers to a position within an ordered list. Python strings can be thought of as lists of characters; each
-----   character can be indexed with -1, the second to last with -2 etc:
	
	P  y  t  h  o  n
   -6 -5 -4 -3 -2 -1
   
- So from what I'm gathering is that the book is telling me that I should be able to call on the keys within 'special_keys' which is 'menu_specials' keys as a list count where I specify the indexed part of the list of keys with 'count=<?>' and then in the script I refer Python to pull that count from 'special_keys' with is actually the keys from 'menu_specials' but Python can't do that because keys cannot be refered to as an indexed object that can be subscriptable the way the values withing the keys can.

PAGE 66/36

One other thing to note about a dictionary is that you can ask the list whether a partifular key already exists. You can use a special built-in method called '_contains_' which will return TRUE or FALSE. When you invoke a method like '_contains_' you are asking a question of it, and it will answer with it's version of yes, which is True or no, which is false.

' .__Contains__ ' - (Contains Boolean) - This will let you know if a certain object is withing a tuple, list or dictionary. There are two underscores before and after the word 'contains', sometimes it -----------------   doesn't look like that. 

	breakfast = ("eggs","bacon","grits","cheese","sausage")
	breakfast
		('eggs', 'bacon', 'grits', 'cheese', 'sausage')
	breakfast[0]
		'eggs'
	breakfast[0,1,2]
		Traceback (most recent call last):
		File "<pyshell#3>", line 1, in <module>
		breakfast[0,1,2]
		TypeError: tuple indices must be integers or slices, not tuple
	breakfast._contains_('grits')
		Traceback (most recent call last):
		File "<pyshell#4>", line 1, in <module>
		breakfast._contains_('grits')
		AttributeError: 'tuple' object has no attribute '_contains_'. Did you mean: '__contains__'?
	breakfast.__contains__('grits')
		True
		
True and false are special values that are actually 1 and 0 (1 is true, and 0 is false), but true and false make more sense, because you are asking a question, 1 or 0 is more ambiguous than true or false, True and False are talked about later on. 

TREATING A STRING LIKE A LIST
Python offers an interesting feature of strings. Sometimes, it is useful to be able to treat string as thought it were a list of individual characters. It's not uncommon to have extraneous characters at the end of a string. People may not recognize these, but computers will get hung up on them. It's also common to only need to look at the first character of a string to know what you want to do with it. For instance, if you had a list of last names and first names, you could view the first letter of each by using the same syntax that you would for a list. This method of looking at strings is called slicing and is one of the fun things about Python. 

SLICING - You can view the first letter of each string in a list by using the syntax you would for a list. You can take section of a sequence and extract a piece from it, making a copy that you can use separately.
-------

PAGE 67/37

	last_names = ["douglass","jefferson","Williams","frank","thomas"]
	print (last_names)
		['douglass', 'jefferson', 'Williams', 'frank', 'thomas']
	print ("%s" % last_names[0])
		douglass
	print ("%s" % lsat_names[0][0])
		Traceback (most recent call last):
		File "<pyshell#3>", line 1, in <module>
		print ("%s" % lsat_names[0][0])
		NameError: name 'lsat_names' is not defined. Did you mean: 'last_names'?
	print ("%s" % last_names[0][0])
		d
	print ("%s" % last_names[1])
		jefferson
	print("%s" % last_names[1][0])
		j
	print("%s" % last_names[2])
		Williams
	print("%s"%last_names[2][0])
		W
	print("%s"%last_names[3])
		frank
	print("%s"%last_names[3][0])
		f
	print("%s"last_names[4])
		SyntaxError: invalid syntax. Perhaps you forgot a comma?
		print("%s"%last_names[4])
		thomas
	print("%s"%last_names[4][0])
		t
	print("%s"%last_names[5])
		Traceback (most recent call last):
		File "<pyshell#14>", line 1, in <module>
		print("%s"%last_names[5])
		IndexError: list index out of range
		
For example, you can use the letter positioning of strings to arrange them into groups in a dictionary based on the first letter of the last name. You don't need to do anything complicated: you can just check to see which letter the string containing the names starts with and file it under that:

	by_letter = {}
	by_letter[last_names[0][0]]=last_names[0]
	by_letter[last_names[1][0]=last_names[1]        
		SyntaxError: '[' was never closed
	by_letter[last_names[1][0]]=last_names[1]      
	by_letter[last_names[2][0]=last_names[2]
          SyntaxError: '[' was never closed
	by_letter[last_names[2][0]]=last-names[3]
        Traceback (most recent call last):
		File "<pyshell#20>", line 1, in <module>
		by_letter[last_names[2][0]]=last-names[3]
		NameError: name 'last' is not defined. Did you mean: 'list'?
	by_letter[last_names[2][0]]=last_names[3]
	by_letter[last_names[3][0]]=last_names[4]
	print (by_letter)
		{'d': 'douglass', 'j': 'jefferson', 'W': 'frank', 'f': 'thomas'}

The 'by_letter' dictionary will, thanks to string slicing, only contain the first letter from each of the last names. Therefore, 'by_letter' is a dictionary omdexed by the first letter of each last name. You could also make each key in 'by_letter' reference a list instead and use the APPEND method of that list to creat a list of names beginning with that letter. If, of course, you wanted to have a dictionary that indexed a larger group of names, where each one did not begin with a different letter. 

Remember that, like tuples, strings are immutable. When you are slicing strings, you are actually creating new strings that are copies of sections of the original string

STRING SLICING IS VERY USEFUL: If you're new to programming, string slicing may seem like an unsual feature at first. Programmers who have used a lower-level language like C or C++ would have learned how to program viewing strings as special lists and in Python you can also slice lists, as you'll be shown, so for them this is natuaral. For you, it will be a very conveinient tool once you've learned how to control repitition over lists. 

TRUE, FALSE, NONE - SPECIAL TYPES  - There are a handful of special types in Python. You've seen them all, but they bear mentioning on their own:
---------------------------------
NONE
TRUE
FALSE
are all special built-in values that are useful at different times. Are special ways of looking at 1 and 0, but when you want to test whether something is true or false, explicitly using the names TRUE and FALSE is always the right thing to do. NONE is a special value that is build into Python that only equals itself, and it is what you received from functions that otherwise would not return any value (Such as True, Flase, a string, or other values) 

NONE - It's a name that no matter how many time you use it, it doesn't match any other object, just itself. When you use functions that don't have anything to return to you, that is, when the funtions doesn't have anything to 
----   respond with it will return NONE.

NONE is special because there is only one NONE. It's a name that no matter how many time you use it, it doesn't match any other object, just itself. When you use functions that don't have anything to return to you, that is, when the funtions doesn't have anything to respond with - it will return NONE. TRUE and FALSE are special representations of the numbers 1 and 0. This prevents a lot of the confusion that is common in other programming languages where the truth value of a statement is arbitrary. For instance, in Unix SHELL 0 is true and anything else if false. With C and Perl, 0 is False and anything else is true. However, in all casses, there are no built-in names to distinguish these values. Pyython makes this easier by explicitly nameing the values. The names TRUE and FALSE can be used in elementary comparisons, which you'll see a lot; and in Chapter 4, you will learn how these comparisons can dramatically affect your programs. In face, they enable oyu to make decisions within your program. 

SHELL - Is both how you interace with the system, as well as a programming language 
-----

	True
		True
	False
		False
	True==1
        True
	False==0
         True
	False==1
		False
	True==0
        False
		
OTHER COMMON SEQUENCE PROPERTIES
The two types of sequences are tuples and lists and as you've seen, in some cases strings can be accessed as though they were sequences as well. Strings make sense because you can view the letters in a string as a sequence. Even though dictionaries represent a group of data, they are not sequences, because they do not have a specific ordering from beginning to end, which is a feature of sequences. 

SEQUENCES - Are defined by having a definite order from beginning to end. The two types of definate sequences are tuples and lists, and sometimes strings can be accessed like a seqeunce because you can view the letters are ---------   strings a sequence. 

REFERNCING THE LAST ELEMENTS
All of the sequence types provide you with some shortcuts to make their use more convenient. You often need to know the contents. of the final element of a sequence, and you can get that informatinon in two ways. One way is to get the number of elements in the list and then use that number to directly access to the value there:

PAGE 69/38

	last_names = ["douglass","jefferson","williams","frank","thomas"]
	print (last_names)
		['douglass', 'jefferson', 'williams', 'frank', 'thomas']
	len(last_names)
		5
	last_element=len(last_names)-1
	print ("%" % last_names[last_element])
		Traceback (most recent call last):
		File "<pyshell#4>", line 1, in <module>
		print ("%" % last_names[last_element])
		ValueError: incomplete format
	print ("%" % (last_names[last_element]))
		Traceback (most recent call last):
		File "<pyshell#5>", line 1, in <module>
		print ("%" % (last_names[last_element]))
		ValueError: incomplete format
	type last_element
		SyntaxError: incomplete input
	type (last_element)
		<class 'int'>
	last_name[4]
		Traceback (most recent call last):
		File "<pyshell#8>", line 1, in <module>
    last_name[4]
		NameError: name 'last_name' is not defined. Did you mean: 'last_names'?
	last_names[4]
		'thomas'
	last_element
		4
	last_name[last_element]
		Traceback (most recent call last):
		File "<pyshell#11>", line 1, in <module>
    last_name[last_element]
		NameError: name 'last_name' is not defined. Did you mean: 'last_names'?
	last_names[last_element]
		'thomas'
	print (last_names[last_element])
		thomas
	type (last_names)
		<class 'list'>
	print ("%s" % last_names[last_element])
		thomas

However, that method takes two steps: and as a programmer, typing it repeatedly in a programs can be time-consuming. Fortunately, Python provides a shortcut that enables you to access the last element of a sequence by using the number -1, and the next-to-last element with -22, letting you reverse the order of the list by using negative numbers from -1 to the number tha is the negative length of the list.

	print ("%s" % last_names[-1])
		thomas
	print ("%s" % last_names[-2])
		frank
	print ("%s" & last_names[-3])
		Traceback (most recent call last):
		File "<pyshell#18>", line 1, in <module>
		print ("%s" & last_names[-3])
		TypeError: unsupported operand type(s) for &: 'str' and 'str'
	print ("%s" % last_names[-3])
		williams
	print ("%s" % last_names[-4])
		jefferson
	print ("%s" % last_names[-2])
		frank
	print ("%s" % last_names[-5])
		douglass
	print ("%s" % last_names[-6])
		Traceback (most recent call last):
		File "<pyshell#23>", line 1, in <module>
		print ("%s" % last_names[-6])
		IndexError: list index out of range
		
RANGES OF SEQUENCES
You can take section of a sequence and extract a piece from it, making a copy that you can use separately. The term for creating these groupings is called slicing. Whenever a slice is created from a list or a tuple, the resulting slice is the same typle as the type from which it was created, and you've already seen this with strings. For example, a slice that you make from a list is a list, a slice you make from a tuple is a tuple. and the slice that you make from a string, is a string. You've already sliced strings, so try using the same idea to slice tuples, lists, and strings and see what the results are side-by-side.

	SlicedTuple=("this","is","a","sliced","tuple")
	SlicedTuple
		('this', 'is', 'a', 'sliced', 'tuple')
	SlicedTupleSliced=SlicedTuple[2:5]
	SlicedTupleSliced
		('a', 'sliced', 'tuple')
	SlicedList=["this","is","a","sliced","list"]
	SlicedListSliced=SlicedList[2:5]
	SlicedListSliced
		['a', 'sliced', 'list']
	SlicedString="this is a sliced string"
	SlicedStringSliced=SlicedString[2:5]
	SlicedStringSliced
		S'is '
		
HOW IT WORKS
IN each case, using the colon to specify a slice of the sequence instructs Python to creat a new sequnce that contains just those elements

GROWING LISTS BY APPENDING SEQUENCES
Suppose you have two lists that you want to join together. You haven't been shown a purposelt built way to do that yet. You can't use APPEND to take on sequence and add it to another. Instead, you will find that you have layered into your list:

	TupleA=("E1","E2","E3","E4")
	TupleA
		('E1', 'E2', 'E3', 'E4')
		('E1', 'E2', 'E3', 'E4')
		('E1', 'E2', 'E3', 'E4')
	ListA=[]
	ListA.append(TupleA)
	ListA
		[('E1', 'E2', 'E3', 'E4')]
		
PAGE 70/40

This is probably not what you want if you were intending to create a list from the contents of the tuple,'tuple a' that could be used to create a list of all the items in the apartment. To copy all of the elements of a sequence, instead of using 'APPEND' you can use the extend method of list and tuple, which takes each element of the sequence you give it and inserts those elements into the list from which it is called:

	living_room=("rug","table","chair","TV","dustbin","shelf")
	apartment=[]
	aprtment.extend(living_room)
		Traceback (most recent call last):
		File "<pyshell#2>", line 1, in <module>
		aprtment.extend(living_room)
		NameError: name 'aprtment' is not defined. Did you mean: 'apartment'?
	apartment.extend(living_room)
	apartment
		['rug', 'table', 'chair', 'TV', 'dustbin', 'shelf']
	TupleA=("a","b","c","d","e")
	ListA=[]
	ListA.extend(TupleA)
	ListA
		['a', 'b', 'c', 'd', 'e']
	TupleA
		('a', 'b', 'c', 'd', 'e')
		
USING LISTS TO TEMPORARILY STORE DATA
' .pop ' - This essential removes an item from a list, if nothing is specified it will remove the last item from the list. Allows you to remove a specific reference to keep data from the list after you're done with it. When you've removed the reference, the position it occupied will be filled with whatever the next element was, and the list will be reduced by as many elements as you've popped. When you call an item to be popped it will be removed from the list that you are calling it from and may need to be replaced to call those elements again. It seems this is helpful if you want to call a position in a list as it's own list just once for some operation and have it go back.
---SHELL---
b = ['dog','cat','racoon','mouse']
b.pop()
print(b)
b.pop(0)
print(b)
b.pop(1)
print(b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
['dog', 'cat', 'racoon']
['cat', 'racoon']
['cat']

Process finished with exit code 0

POPPING ELEMENTS FROM A LIST
You need to tell pop which element it is acting on. If you tell it to work on element 0, it will pop the first itme in it's list, while passing pop a parameter of 1 will tell it to use the item at position 1 (the second element in the list), and so on. The element pop acts on is the same number that you'd use to acces the list's elements using square brackets:

	ListB=["f","g","h","i"]
	ListB.append("j")
	ListB
		['f', 'g', 'h', 'i', 'j']
	PopElements=ListB.pop(0)
	print ("this morning temperature was %.02f" % PopElements)
		Traceback (most recent call last):
		File "<pyshell#15>", line 1, in <module>
		print ("this morning temperature was %.02f" % PopElements)
		TypeError: must be real number, not str
	ListB=[1,2,3,4,5]
	ListB
		[1, 2, 3, 4, 5]
	print ("this mornings temperature was %.02f" % PopElements)
		Traceback (most recent call last):
		File "<pyshell#18>", line 1, in <module>
		print ("this mornings temperature was %.02f" % PopElements)
		TypeError: must be real number, not str
	PopElements
	'f'
	PopElements=ListB.pop(0)
	PopElements
	1
	print ("this mornings temperature was %.02f" % PopElements)
		this mornings temperature was 1.00
		
HOW IT WORKS
When a values is popped, iF the action is on the right-hand side of an equals sign, you can assign the element that was removed to a value on the left-hand side, or just use that value in cases where it would be appropriate. If you don't assign the popped values or otherwise use it, it will be discarded from the list. You can also avoid the use of an intermediate name, by just using 'POP' to populate, say, a strong format, because pop will return the specified element in the list, which can be used just as though you'd soecified a number or a name that referenced a number. If you don't tell pop to use a specific element from the list it's invoked from it will remove the last element of the list, not the first as shown here.

	print ("trying to add decimals to a element in ListB will be %.02f" % ListB.pop(0))
		trying to add decimals to a element in ListB will be 2.00
	print ("trying to add decimals to an element in ListB will be %.02f" % ListB[2])
		trying to add decimals to an element in ListB will be 5.00
		
- I'm not quite sure the use of POP but I'll practice it anyway. 

SUMMARY
TUPLES
LISTS
DICTIONARIES
NONE
TRUE
FALSE

CHAPTER 4: MAKING DECISIONS
In this chapter, you'll learn about how Python makes decisions using True and False and how to make more complex decisions based on whether a condition is True or False. You will learn how to create situatioonsin which you can repeat the same actions using loops that give you the capability to automate stepping through list, tuples and dictionaries. You'll also learn how to use lists or tuples with dictionaries cooperatively to explore the contents of a dictionary. You will also be introduced to exception handling, which enables you to write your programs to cope with problematic situations that you can handle within a program. 

COMPARING VALUES: ARE THEY THE SAME?
You saw True and False in Chapter 3 but you werent introduced to how they can be used. True and False are the results of compring values, asking questions, and performing other actions. However, anything that can be given a value and a name can be compared with the set of comparison operations that return True and False. 

COMPARING VALUES FOR SAMENESS
Testing for equality is done with two equals signs, remember that the single equal sign will bind data to a name, which is different from what you want to do here, which is elicit a T of F. 

	1==1
		True
	1==2
		False
		
'==' (EQUAL) - Will compare two elements and return a true of false value depending on if they are equal or not. 
--------------		

HOW IT WORKS
When you use the equality comparison, Python will compare the values on both sides. If the numbers are different, False will be the result. If the numbers are the same, then True will be the result. If you have different types of numbers, Python will still be able to compare them and give you the correct answer:

	1.23==1
		False
	1.0==1
		True
		
You can also use the double equals to test whether strings have the same contents, and you can even restrict this test to ranges withing the strings, remember from the last chapter that slices create copies of the part of the string they reference, so youre really comparing two strings that represent just the range that a slice covers

	a = "MacintoshApples"
	a
		'MacintoshApples'
	b="BlackBerries"
	c="GoldenDeliciousApples"
	a==b
		False
	b==c
		False
	a[-len("apples"):-1]==c[-len("apples");-1]
		SyntaxError: invalid syntax
	a[-len("apples");-1]==c[-len("apples"):-1]
		SyntaxError: invalid syntax
	a[-len("apples"):-1]==c[-len("apples"):-1]
		True
		
Sequences can be compared in Python with the double equals as well. Python considers two sequences to be equal when every element in the same position is the same in each list. Therefore, if you have three items each in two sequences and they contrain the same data but in a different order, they are NOT equal. 

	Apples=["macintosh","GoldenDelicious","Fuji","Mitsu"]
	AppleTrees=["GoldenDelicious","Fuji","Mitsu","Macintosh"]
	Apples==AppleTrees
		False
	AppleTress=["macintosh","GoldenDelicious","Fuji","Mitsu"]
	Apples==AppleTrees
		False
	Apples
		['macintosh', 'GoldenDelicious', 'Fuji', 'Mitsu']
	AppleTrees
		['GoldenDelicious', 'Fuji', 'Mitsu', 'Macintosh']
	AppleTrees
		['GoldenDelicious', 'Fuji', 'Mitsu', 'Macintosh']
	AppleTrees=["macintosh","GoldenDelicious","Fuji","Mitsu"]
	AppleTrees
		['macintosh', 'GoldenDelicious', 'Fuji', 'Mitsu']
	Apples==AppleTrees
		True
		
In addition, dictionaries can be compared. Like lists, every key and value in one dictionary has to have a key and value in the other dictionary in which the key in the first is equal to the key in the second, and the value in the first is equal to the value in the second. 

	BreakfastSoldTuesday={}
	BreakfastSoldTuesday["Pancakes"]=8
	BreakfastSoldTuesday
		{'Pancakes': 8}
	BreakfastSoldTuesday["FrenchToast"]=5
	BreakfastSoldTuesday["Bagels"]=15
	BreakfastSoldTuesday["Omelets"]=85
	BreakfastSoldTuesday["EggsSausage"]=40
	BreakfastSoldTuesday
		{'Pancakes': 8, 'FrenchToast': 5, 'Bagels': 15, 'Omelets': 85, 'EggsSausage': 40}
	BreakfastSoldWednesday={"Pancakes":8,"FrenchToast":5,"Bagels":20,"Omelet":12,"EggsBacon":56}
	BreakfastSoldTuesday==BreakfastSoldWednesday
		False
	BreakfastSoldThurday={"Pancakes":8,"FrenchToast":5,"Bagels":15,"Omelets":85,"EggsSausage":40}

	BreakfastSoldTuesday==BreakfastSoldThursday
		Traceback (most recent call last):
		File "<pyshell#31>", line 1, in <module>
		BreakfastSoldTuesday==BreakfastSoldThursday
		NameError: name 'BreakfastSoldThursday' is not defined. Did you mean: 'BreakfastSoldThurday'?
	BreakfastSoldTuesday==BreakfastSoldThurday
		True

DOING THE OPPOSITE: NOT EQUAL
There is an opposite operation to the equaliry comparison. If you use the exclamation and equals together, you are asking Python for a comparison between any two values that are not equal according to the rules established to make elements resolve to a True value. 

'!=' (UNEQUAL) - This operates as the inverse of the EQUAL function where it will compare two elements and if they are DIFFERENT you will get TRUE and if the are the SAME you will get FALSE
--------------

TRY IT OUT: COMPARING VALUES FOR DIFFERENCE

	3==3
		True
	3!=3
		False
	5!=4
		True

HOW IT WORKS
Every pair of number that would generate a True result when they're compared using the == will now generate a False, while any two numbers that would have generated a False when compared using == will now result in True. These rules hold true for all of the more complex types, like sequences and dictionaries:

	TuesdayBreakfastSold={}
	ThursdayBreakfastSold={}
	TuesdayBreakfastSold!=ThursdayBreakfastSold
		False
	TuesdayBreakfastSold==ThursdayBreakfastSold
		True
	WednesdayBreakfastSold={"pancake":5}
	TuesdayBreakfastSold!=WednesdayBreakfastSold
		True
	ThursdayBreakfastSold!=WednesdayBreakfastSold
		True

Like numbers, any situation that would be true with == will be False with != with these types. 

COMPARING VALUES: WHICH ONE IS MORE?
Equality isnt the only way to find out what you want to know. Sometimes you will want to know whether a quanitity of something is greater than that of another, or whether a value is less than some other value. Python has GREATER THAN and LESS THAN operations that can be invoked with the > and < characters. There are the same symbols you are familiar with from math books, and the question is always asking whether the value on the left is greater than or less than the value on the right. 

	5<3
		False
	10>2
		True
		
HOW IT WORKS
The number on the left is compared to the number on the right. You can compare letters, too. There are a few conditions where this might no do what you expect, such as trying to compare letters to numbers. The values of the letters in the alphabet run roughly this way: A capital 'A' is the lowest letter, followed by 'B' follow by 'C' until 'Z' and then that is followed by the same in lowercase
with 'z' being the highest and 'a' being higher than 'Z'.

	"a">"b"
		False
	"A">"b"
		False
	"A">"a"
		False
	"b">"A"
		True
	"Z">"a"
		False
		
If you wanted to compare two strings that were longer than a single character, Python will look at each letter until it finds one that's different. When that happens, the outcome will depend on that one difference. If the strings are completely different, the first letter will decide the outcome:

	"Zebra" > "aardvark"
		False
	"Zebra">"Zebrb"
		False
	"Zebra"<"Zebrb"
		True

You can avoid the problem of trying to compare two words that are similar but have differences in capitalization by using a special method of strings called LOWER, which acts on it's string and returns a new string with all lowercase letters. There is also a corresponding UPPER method. These are available for every string in Python.

PAGE 76/46

	"Pumpkin"=="pumpkin"
		False
	"Pumkin.lower"=="pumpkin.lower"
		False
	Pumpkin.lower==pumpkin.lower
		Traceback (most recent call last):
		File "<pyshell#2>", line 1, in <module>
		Pumpkin.lower==pumpkin.lower
		NameError: name 'Pumpkin' is not defined
--------------------------------------------------
	"Pumpkin.lower"=="pumpkin.lower"
		False
	"Pumpkin".lower()=="pumpkin".lower()
		True
	"Pumpkin".upper()=="pumpkin".upper()
		True
	"pumpkin".upper()
		'PUMPKIN'

When you have a string reference by a name, you can still access all of the methods that string normally have:

	gourd = "Calabash"
	gourd
		'Calabash'
	gourd.lower()
		'calabash'
	gourd.upper()
		'CALABASH'
		
MORE THAN OR EQUAL, LESS THAN OR EQUAL
There is a useful variation on greater than and less than, It's common to think of things in terms of greater than or less than or equal to. You can use a simple shorthand to do that: Join the two symbols in a way that makes sens when you look at it. 

	1>1
		False
	1>=2
		False
	10<10
		False
	10<=10
		True
		
REVERSING TRUE AND FALSE
When you are creating situations where you're comparing their outcomes, sometimes you want to know whether something is true, and sometimes you want to know whether smething is not true. Sensibly enough, Python has an poeration to create to opposite situation, the word not proves the opposit of the truth value that follows it. 

TRY IT OUT : REVERSING THE OUTCOME OF A TEST

	not True
		False
	not 5
		False
	not 0
		True
		
HOW IT WORKS
The NOT operation applies to any test that results in a True or False. However, remember from Chapter 3 that anything that's not zero will be seen as True, so you can use NOT in many situations where you wouldn't expect it or where it doesn't make sense.

	5>2
		True
	not "A" < 3
		Traceback (most recent call last):
		File "<pyshell#20>", line 1, in <module>
		not "A" < 3
		TypeError: '<' not supported between instances of 'str' and 'int'
	not A<3
		Traceback (most recent call last):
		File "<pyshell#21>", line 1, in <module>
		not A<3
		NameError: name 'A' is not defined
	not "A"<3
		Traceback (most recent call last):
		File "<pyshell#22>", line 1, in <module>
		not "A"<3
		TypeError: '<' not supported between instances of 'str' and 'int'
	not (A<3)
		Traceback (most recent call last):
		File "<pyshell#23>", line 1, in <module>
		not (A<3)
		NameError: name 'A' is not defined
	not "A"<"z"
		False
		
LOOKING FOR THE RESULTS OF MORE THAN ONE COMPARISON
You can also combine the results of more than one operation, which enables your programs to make a more complex decisions by evalutating the tru valies of more than one operation. One kind of combination is the AND operation, which says "if the opertion, value, or object of my left evaluates being true move to my right and evaluate that. If it doesn't evaluate to True, just stop and say False, don't do anymore"

'AND' - And compares terms on the left and right and is the left value is evaluated as TRUE then it will move on to the right value. So that if the first term is false the whole and statment will return
-----   false.

The other kind of combining operation is the OR compound. Using the OR tells Python to evaluate the expression on the left and it if is False, Python will evaluate the expression on the right. If it is True, Python will stop evaluation of any more expressions.
	
	True or True
		True
	True or False
		True
	False or True
		True
	False or False
		False
		
You may also want to place sequences of these together base on actions you want to happen. In these case, evaluation starts with the leftmost AND or OR and continues following the rules above, in other words, until a False value is evaluated for AND, or until a TRUE value is evaluated for OR. 

HOW TO GET DECISIONS MADE
Python has a very simple way of letting you make decisions. The reserved word for decisions making is IF, and it is followed by a test for the truth of a condition.

'IF'...:' -  This operator that allows you to make decisions and it is followed by a test for the truth of a condition, and the test is ended with a colon, so you'll see it referred to here as IF...It can be used with anything that evaluates to True or False to ---------    say "if something is true, do what follows":. It seems like for each line of code associated with an IF...: operation there will be a black line indicating Python is evaluating the code being run and will return a value beneath that. 

	if 1 > 2:
		print ("no it is not")

	of 2 > 1:
		SyntaxError: invalid syntax
	if 2>1
		SyntaxError: incomplete input
	if 2 > 1
		SyntaxError: incomplete input
	if 2 > 1:
		print ("yes it is")

		yes it is
		
You have just seen one of the most distinctive visual aspects of Python and the one that most people remark on when they encounter Python. When you see the colon in Python programs, it's an indication that Python is entering a part of its program that is partially isolated from the rest of the program. At the point, indentation becomes important. The indentation is how Python knows that a particular block of code is separate from the code around it. The number of spaces used is important, and a Python-oreiented programming editor wil always carefully help you maintain the proper indentation for the code that is being written. The number of spaces is relevant, so it is imporatant to use the editor to determine your indentation and not change the number of spaces manually. You will see more keywords paried with the colon: an in all cases, you need to pay attention to the indentation. Python will warn you with an error if your program has changes in indentation that it doesn't understand. 

Only when the statement to be evaluated between the if and the colon evaluate to True will the indented statments below be visited by Python to be evaluated. The indentation indicates that the code that follows it is a part of the program but is only executed only if the right conditions occur. For the IF...: statement, the proper condition is when the comparison being made evaluates to TRUE. Ypu can place IF...: statment within the indentation of other IF...: to perform more complex decision than what can be achieved with AND and OR because using IF...: enables you to perform any series of statements that you may need before evaluating the indented IF...: statement.

TRY IT OUT PLACING TESTS WITHIN TESTS
Try the following example, where one IF>>>: appears within another:

	if fridge_contents["egg"]>omelet_ingredients["egg"]:
		have_ingredients[0]=False
		have_ingredients.append("egg")

    
	if fridge_contents["mushrooms"] > omelet_ingredients["mushroom"]:
		if have_ingredients[0]==True:
			have_ingredients[0]=False
		have_ingredients.append("mushroom")

    
		Traceback (most recent call last):
		File "<pyshell#11>", line 1, in <module>
		if fridge_contents["mushrooms"] > omelet_ingredients["mushroom"]:
		KeyError: 'mushrooms'
	if fridge_contents["mushroom"] > omelet_ingredients["mushroom"]:
		if have_ingredients[0]==True:
			have_ingredients[0]=False
		have_ingredients.append("mushroom")
		
HOW IT WORKS
After a condition is tested with an IF...: and, there is an additional level of indentation, Python will continue to evaluate the rest of the code that you've placed in the indentation. If the first IF...: isn't true, then none of the code below it will be evaluated, it would be skipped entirely. However, if the first IF...: statement is true, the second one at the same level will be evaluated. The outcome of a comparison only determines whether the indented code beneath it will be run. Code at the same level, or above won't be stopped without something special happening, like an error or another condition that would prevent the program from continuing to run. Code at the same level, or above, won't be stopped without something special happening, like an error or another condition that would prevent the program from continuing to run. 

	if 3 > 1:
		print ("three is greater that one")

    
	three is greater that one
		if 3 > 1:
			if 2 > 1:
				if 1==1:
					print("success")

            
		success
	if 2>1 and 2!=1:
		if 3==3:
			print("success")
     
		success
	if 2>1 or 1!=1
		SyntaxError: incomplete input
	if 2>1 or 1!=1:
		print("bop")

    
		bop
	if 1!=1 or 2>1:
		print("boptoo")


	boptoo
	if 1!=1 and 2>1:
		print("nada")

- So I was having an issue understanding part of the code, specifically the first IF...: operation stating "if fridge_contents["pepper"] > omelet_ingredient["pepper"]:" I was confused on how Python was to evalute these elements because they look like some complex string but these are keys to a dictionary and they are paired with values. It weird because these elements show everything but the value and I think to see the value of a key you have to use 'LEN' operator. Actually that is incorrect, you will get a integer by just evaluating the key of said dictionary:

	len(fridge_contents["egg"])
		Traceback (most recent call last):
		File "<pyshell#44>", line 1, in <module>
		len(fridge_contents["egg"])
		TypeError: object of type 'int' has no len()
	fridge_contents["egg"]
		10
		
You can create a chain of tests beginning with IF...: using ELIF...:.ELIF...: enables a variety of conditions to be tested for but only if a prior condition wasn't met. If you use a series of IF...: statements they will all be executed. If you use an IF...: followed by an ELIF...:, the ELIF...: will be evaluated only if the IF...: results in a False value: 

'ELIF' (Else If) - This allow you to add another dimension to an if state by stating there is something other that the truth value in the first if statment and it's parameters are as follows
----------------
	80/50

	MilkPrice=1.50
	if MilkPrice < 1.25:
		print ("buy two cartons of milk, they're on sale")
	elif MilkPrice < 2.00:
		print ("buy one carton of milk, prices are normal")
	elif MilkPrice > 2.00:
		print ("go somewhere else! Milk cost's too much here")

    
	buy one carton of milk, prices are normal
	
There is also a fall-through statement that you can insert to handle those cases where non of the prior test resulted in a True value, the ELSE: statement. If non of the IF...: or ELIF...: statements have test conditions that evaluate to TRUE, the else" clause is invoked. 

	OJPrice=2.50
	if OJPrice<1.25:
		print("get one im thirsty")
	elif OJPrice<=2.00:
		print("Sure, but I'll drink it slowly")
	else:
		print("I don't have enough money. never mind")

    
		I don't have enough money. never mind

REPETITION 
You have seen how many times every element in a sequence, or every element in a dictionary, needs to be examined and compared. Doing this manually is impossibly boring and error prone for a person, even a fast touch typist. In addition, if you enter these things in manually, you'll be caught off-guard when the inevitable typo happens, or when something that you're evaluating is changed elsewhere, and your manually entered code can't easily accomodate that change. To preform repetitive tasks, Python, offers two kinds of repetition operations. Both are similar in fact, theyre almost identical but each one lets you think about what you're doing differently so each oen should have it's place in your skill set

HOW TO DO SOMETHING AGAIN AND AGAIN 
The two operations that enable you to initiate and control repetitive tasks are the WHILE and FOR operations. The while operation tests for one truth condition, so it will be referred to as 'WHILE...:'. The FOR operation uses each value from within a list, so it will be referred to as 'FOR...IN...:'. The 'WHILE...' operation will first check for it's test condition, the ...between the while and the :, and if it is TRUE, it will evaluate the statements in its indented block a first time. After it reaches the end of its indented block, which can include other blocks, that it may contrain, it will once again evaluate it's test condition to see whether it is stil TRUE. If if is, it will repeat its action again, however, it if is FALSE, Python leaves the indented section and continues to evaluate the rest of the program after the 'WHILE...:' section. When names are used in the test condition, then between the first repetition and the next, and the next and so on, the value referred to by the name could have changed and on and on until there is some reason to stop. 

TRY IT OUT: USING A WHILE LOOP

PAGE 81/51

SHELL
_____
omelet_ingredients = {"cheese":2,"pepper":2,"egg":2,"mushroom":2,"milk":2}
print (omelet_ingredients)
ingredients=omelet_ingredients.keys()
print (ingredients)
while len(ingredients)>0:
    current_ingredient=ingredients.pop()
    print ("adding %d %s to the mix" % (omelet_ingredients[current_ingredient],current_ingredient))
	
TERMINAL
________
{'cheese': 2, 'pepper': 2, 'egg': 2, 'milk': 2, 'mushroom': 2}
['cheese', 'pepper', 'egg', 'milk', 'mushroom']
adding 2 mushroom to the mix
adding 2 milk to the mix
adding 2 egg to the mix
adding 2 pepper to the mix
adding 2 cheese to the mix

HOW IT WORKS
In making this omelet, first you have taken the list of 'ingredients' from the 'omelet_ingredients' dictionary. The dictionary contains both the ingredients and the corresponding quatities that are needed for an omelet. The 'ingredients' list only has the names of the ingredients. The repetition using the 'while...:' operation will ensure that at least one element is left in the 'ingredients' list. For as long as there are elements in 'ingredients', the looping repitition will use 'pop' to remove the last element from the ingredients list and reference it's value with the name 'current_ingredient' . Then, in the 'print' statement, the 'current_ingredient' is always going to be the name of an ingredient from the keys of the 'omelet_ingredients' dictionary because that's where the list 'ingredients' came from. Doing this the other way, with the 'for...in...:' form of repetition, is as shown before, very similar to the 'while...:' form, but it saves you a couple of steps. IN the first part, the 'for...in...:' form of repetition, is, as shown before, very similar to the 'while...:' form, but it saves you a couple of steps. In the first part, the 'for...', you provide a name that you will use inside of the indented code. In the second part, the 'in...:' part, you provide a sequence, such as a list or tuple, which takes each element and assigns the value of the element to the name you provided in the first part. This saves you some of the effort that went in to using the 'while' loop in showing the omelet ingredients being put together:

- What is the difference between %d and %i?
	%d is an integer inclusion that will accept decimal points, or floats and regular numbers. So like accept all numbers in all formats. 
	
SHELL
_____
omelet_ingredients={"cheese":1,"steak":2,"eggs":3,"mushroom":4,"milk":5}
ingredients=omelet_ingredients.keys()
for ingredients in omelet_ingredients.keys():
    print ("adding %d %s to the mix" % (omelet_ingredients[ingredients],ingredients))
	
TERMINAL
________
adding 1 cheese to the mix
adding 2 steak to the mix
adding 3 eggs to the mix
adding 4 mushroom to the mix
adding 5 milk to the mix

You can see that this method if performed in the opposite order of the 'while...:' example. This is because the first example used the 'pop' method to remove elements from the end of the list, but the second example with 'for...in...:' uses each element in the keys of the 'omelet_ingredients' in order from first to last. 

STOPPING THE REPETITION 
The common term 'infinite loop' refers to a sequence of code that will repeat forever. A simple example just sets up a 'while...:' statement that tests against something that is always going to result in True. For instance, just using True will always work. You should not type in the following code, because it's the kind of thing that's better to see that to have to do yourself:

	while True:
		print ("you're going to get bored with this quickly")
		
	You're going to get bored with this quickly
	You're going to get bored with this quickly
	You're going to get bored with this quickly
	You're going to get bored with this quickly
	You're going to get bored with this quickly
	
The preceding code continue forever or until you break out of it. Inconvenient as it seems at first glance to have something that repeats forever, there are times you may want this - for instance, in a program that waits for the user to type something in, and when the user is done, returns to waiting. However, sometimes you will want to know that if certain condition are met, such as the right time of day, when the water has run out, when there are no more eggs to be made into omelets, and so on, that the repetition can be broken out of even when there is no explicit test in the top of the 'while...:' or when the list that's being used in the 'for...in...:' doesn't have an end. Infinite loops can be exited by using the 'break' statement. Some of the lines in the example here continue for a long time. When you try this out, if you see a line that doesn't begine with a >>> or a..., then it's actually part of the prior line, so type the entire line. In addition, make sure your indentation matches what's on the page:  

- This is alot to understand here so let me try and figure out what it is I'm trying to figure out here. So they are trying to get the programs to count down the ingredients to an omelettes.

83/53

|SHELL|
omelette_ingredients = {"eggs":2,"mushroom":2,"pepper":2,"cheese":2,"tomato":4,"milk":10}

omlettes_ordered = 5
omlettes_delivered = 0
fridge_contents = {"egg":8, "mushroom":20, "pepper":3, "cheese":2, "tomato":4, "milk":13}

while omelettes_delivered < omelettes_ordered:
    break_out = False
    for ingredient in omelette_ingredients.keys():
          ingredients_needed = omelette_ingredients[ingredient]
          print ("adding %d %s to the mix" % (omelette_ingredients[ingredient],ingredient))
          fridge_contents[ingredient] = fridge_contents[ingredient] - ingredients_needed
          if fridge_contents[ingredients] < ingredients_needed:
              print ("there isnt enough %s for another omelet!" % ingredient)
              break_out = True
    omelets_delivered = omelets_delivered + 1
    print ("one more omelet made! %d more to go" % (omelettes_ordered - omelets_delivered))
    if break_out == True
    print ("out of ingredients, go shopping if you want to make more omelettes!")
    break

|TERMINAL|
  File "/home/jdoodle.py", line 18
    if break_out == True
                        ^
SyntaxError: invalid syntax

- Not sure on this one but it's day two of trying to get this dense shit to run and we're just going to move along.

If you use 'BREAK', it will only take you out of the most recent loop, if you have a 'WHILE...:' loop that contains a "FOR...IN...:' loop indented within it, a 'BREAK' within the "FOR...IN...:" will note break out of the "WHILE...:". Both 'while...:' and 'for...in...' loops can have an else: statment at the end of the loop, but it will be run only if the loop doesn't end due to a 'break' statement. In this case, 'else:' could be better names something like 'done' or 'on_completion', but 'else:' is a conveinient name because you've already seen it and it's not hard to remember

|SHELL|
food = ["pate","cheese","crackers","yogurt"]

for food in ("pate","cheese","crackers","yogurt"):
    if food == "yogurt":
        print ("working")
else:
    print ("there is no yogurt")
	
|TERMINAL|
working
there is no yogurt

- I'm not sure what they are trying to say here but I'm going to do some experimentation with 'while...:' and 'for...in...:' loops myself and see what they are trying to explain if I can make it work

|SHELL|
for food in ("pate","cheese","crackers","yogurt"):
    if food == "yogurt":
        break
else:
    print ("there is no yogurt")
    
for food in ("pate","cheese","crackers"):
    if food == "yogurt":
        break
    
else:
    print "there is no yogurt"

|TERMINAL|
there is no yogurt

HOW IT WORKS
In each example, there is test to determine whether there is any yogurt. If there is, the "while...:" is terminated by using a 'break'. However, in the second loop, there is no yogurt in the list, so when the loop terminates after reaching the end of the list, the 'else:' condition is invoked. There is one other commonly used feature for loops, the 'continue' statement. When continue is used, you're telling Python that you do not want the loop to be terminated, but that you want to skip the rest of the current repitition of the loop, and if you're in a 'for...in...:' loop, re-evaluate the conditions and the list for the next round 

'continue' -  telling Python that you do not want the loop to be terminated, but that you want to skip the rest of the current repitition of the loop, and if you're in a 'for...in...:' loop, re-evaluate the conditions and the ----------    list for the next round.

TRY IT OUT: USING CONTINUE TO KEEP REPEATING

|SHELL|
for food in ("pate","cheese","crackers","yogurt","rotten apples","crackers","whipped cream","tomato soup"):
    if food[0:7] == "rotten":
        continue
    print ("hey, you can eat %s" % food)
    
|TERMINAL|
hey, you can eat pate
hey, you can eat cheese
hey, you can eat crackers
hey, you can eat yogurt
hey, you can eat rotten apples
hey, you can eat crackers
hey, you can eat whipped cream
hey, you can eat tomoato soup

- Ok upon further investigation the code was supposed to print everything except for "rotten apples" but it still printed it anyway. I need to go into more depth about that but my day is almost over. 

 think I'm going to restart chapter 4 because this still isn't really making much sense to me, I think I was distracted when I was trying to learn this
 
 PAGE 79/49
MAKING DECISIONS
Basically when using a 'if...:' operator the statment has to be true for python to move to the indented line caused by the colon. The indentation indicates that the code that follows is is a part of the program but it only executed if the right condition occur. For the 'if...:' statement, the propert condition is when the comparison being made evalutes True. You can place 'if...:' statements within the indentation of other 'if...:' statements to perform more complex decisions than what can be achieved with 'and' and 'or' because using 'if...:' enables you to perform any series of statements that you may need before evaluating the indented 'if...:' statement

'if...:' - This is an operator used to get Python to make a decision, the statement following the 'if' must resolve to true for Python to evaluate the indented statement following the ':'. 

_ So I'm not understand how an if statement determines itself to be true and moves to another if statement below that is also needing to be determined to be true. What happens when an indented if statement is false and an true indented if statement is place below that. Lets try:

SHELL
_____
if 1<5:
    if 2<1:
        if 3<5:
            print("this shouldnt work")
if 1<5:
    if 2<5:
        if 3<5:
            print("this should work")

TERMINAL
________
this should work

- So as we can see the action is probably a better place to start to understand how the if statements are behaving. Given the entire program here. If an 'if' statement can pass a false argument then "this shouldn't work" should have been printed but it was not, only "this should work" was printed an all 3 'if' statement result in true. 

- Even still I don't understand why you would use an if statment to do something like this instead and and or the same program could be written this way. 

SHELL
_____
if 1<5 and 2<1 and 3<5:
    print ("this shouldn't work")
if 1<5 and 2<5 and 3<5:
    print ("this should work")
	
TERMINAL
________
this should work

- As you can see it still works this way too so I'm not really understanding why you would pick another level of 'if' for this but I think I'm understanding it to mean that because 'if' exists you can now use 'and' and 'or' to set up parameters that need to be met for Python to make a decision to move forward with a part of the program the requires those parameters. I don't think you can make the same program using just 'and' and 'or'. Lets try it. 

- One thing I'm having an issue with in this IDE online it a way to show the value of something like a greater than or less than situation. Like I can place in 1<5 and terminal will not return True. I wonder how I get that to happen. 

'RETURN VALUE' - What I am referring above is the return value that is generate and can be used by the computer to 
--------------   to do something with but it is not always seen. 

- Okay, I see now, in order to get a return value to show in the terminal you do have to use 'print' and put the equation in this case in parentheses. It will print out the return value. 

79/49

- It occured to me that 'if...' has more parts to it and there reason I couldn't tell the difference between it and 'and' or 'or' is because if is the part that does operate like there operators There is still 'esleif...:' and 'else...:' which are all a part of what I was referring to as 'if...' so from now on it will be referred to as 'ifelseifelse...:' that way I can remember them. Lets try to make a statment using all three. 

SHELL
_____
if 1<5:
    print ("this is true")
elseif 1<2:
    print ("this is also true")
else 1 == 1:
    print ("this third thing is true too")
	
TERMINAL
________
  File "/home/jdoodle.py", line 3
    elseif 1<2:
           ^
SyntaxError: invalid syntax

- So we can tell from what happened above that I don't know how to use 'ifelseifelse...:' correctly and need to review that so we'll do that now. Particularly else if and else. That because it is called 'elif' not 'elseif'. 

'elif...:' - Creates a chain of tests after the 'if...:' statement. Enables a variety of condition to be tested for but only if a prior condition conditions wasn't met. If you use a series of 'if...:' statements they will all ----------   be executed. If you use an 'if...:' followed by and 'elif...;', the 'elif' will only be evaluted if the 'if...:' statment was false. 

- So lets write a piece of code that is an example of this:

SHELL
_____
if 5<1:
    print ("this should not print")
elif 1<5:
    print ("this should print")
	
TERMINAL
________
this should print

- So that worked correctly and I'm assuming that using 'else...:' is another failsafe for when 'elif...:' evaluates a false statement so lets try false statements in an 'if...:' and 'elif...' statements with a true 'else...:' statement and see what happens. 

SHELL
_____
if 5<1:
    print ("this should not print")
elif 5<2:
    print ("this should not print either")
else 2<5:
    print ("this should print")
	
TERMINAL
________
File "/home/jdoodle.py", line 5
else 2<5:
     ^
SyntaxError: invalid syntax

- So it seems there is something configured wrong in the else statement so let me do some reasearch on that too and see what I've done wrong. You don't put an argument in 'else' so its not 'else...:' it is just 'else:' and it means if all the conditions above fail, do this.

'if...:' - This is an operator used to get Python to make a decision, the statement following the 'if' must resolve to true for Python to evaluate the indented statement following the ':'. 

'elif...:' - Creates a chain of tests after the 'if...:' statement. Enables a variety of condition to be tested for but only if a prior condition conditions wasn't met. If you use a series of 'if...:' statements they will all ----------   be executed. If you use an 'if...:' followed by and 'elif...;', the 'elif' will only be evaluted if the 'if...:' statment was false. 

'else:' - If all the conditions in the 'if...:' and 'elif...:' statements above 'else:' fail this tells the program what to do an does not accept any arguements. 
-------

- Awesome, so lets try to write some code that utilizes this. Maybe a scenario where this is relevant or really just mess around with the concept and see what can be done

USING STRINGS COMPARED BY ORDER
SHELL
_____
if "a"<"B":
    print ("this should not print")
elif "a"<"Z":
    print ("this should not print either")
else:
    print ("this should print")
	
TERMINAL
________
this should print

DEFINING A INTEGER VARIABLE AND COMPARING IT TO A REGULAR INTEGER
SHELL
_____
AnInteger=70
print (AnInteger)
if 60>AnInteger:
    print ("this should not print")
elif 60>AnInteger:
    print ("this should not print")
else:
    print ("this should print")
	
TERMINAL
________
70
this should print

- I think we can move on now

The books gives the following example:
PRE-SHELL
_________
1. Create a dictitonary for FridgeContents
2. Create a dicitonary for OmeletIngredients

'if have_ingredients[0] == True:' - This statemetnt is an 'if...:' stemement asking about the ingredients that we ---------------------------------   have and spefically about the ingredients in the 0 position of the list called "have_ingredients" which has yet to be created in this case but is being named here now in order to count the ingredients that we, the user, will have in the future. So to use this practically I create two dictionaries and then create an empty list which should look something like '>>>empty_list = empty_list[]". To test this I can then append something from one of the Dictionaries to the list and print the list to see if the contents stuck. Lets give that a try. 

SHELL
_____
FridgeContents = {"eggs":2,"cheese":2,"bacon":2,"hashbrowns":2,"seasoning":2}
OmletIngredients = {"eggs":0,"cheese":0,"bacon":0,"hashbrowns":0,"seasoning":0}

EmptyList=[]
EmptyList.append(FridgeContents.keys())
print (EmptyList)

TERMINAL
________
[dict_keys(['eggs', 'cheese', 'bacon', 'hashbrowns', 'seasoning'])]

- So we can see from this one that the keys of the dictionary did get added to the list called EmptyList but I only wanted to add one key at a time and not all of them but I couldn't figure out how to specify a single key in the code without getting an error. Maybe I need to try this idea of appending from one thing to another with just lists instead of dictionaries.

SHELL
_____
FridgeContents=["cheese","bacon","eggs","hashbrowns","spinach"]
print (FridgeContents)
print (FridgeContents[0])

EmptyList=EmptyList.append(FridgeContents[0])
print (EmptyList)

TERMINAL
________
['cheese', 'bacon', 'eggs', 'hashbrowns', 'spinach']
cheese

Traceback (most recent call last):
  File "/home/jdoodle.py", line 5, in <module>
    EmptyList=EmptyList.append(FridgeContents[0])
NameError: name 'EmptyList' is not defined

- I clearly do not know how to use append so I need to go back and review that. Append is only specific to appending to lists it is a built-in of the list type which is why it doesn't work on dictionaries
CHAPTER 3 | pg.34
You can add elements at the end by using the 'append' method that is build in to the list type. 

'.append' - This is a built-in of the list type and is used to add a element to a list.

'pop' - Allows you to remove a specific reference to keep data from the list after you're done with it. When you've removed the reference, the position it occupied will be filled with whatever the next element was, and the -----   list will be reduced by as many elements as you've popped. When you call an item to be popped it will be removed from the list that you are calling it from and may need to be replaced to call those elements again. 

- This brings into question better understanding 'pop' as well which is sort of like the opposite of 'append' in as it can removed a named element from a list according to it's position I believe, lets try that out to make sure. 

SHELL
_____
Donnington=["turn1","turn2","turn3","turn4","turn5"]
print (Donnington)
Donnington.pop()
print (Donnington)
Donnington.append("turn5")
print (Donnington)
Donnington.pop(0)
print (Donnington)
Donnington.append("turn1")
print (Donnington)
DonningtonNew = Donnington.append("new")
print (DonningtonNew)
print (Donnington)

TERMINAL
________
['turn1', 'turn2', 'turn3', 'turn4', 'turn5']
['turn1', 'turn2', 'turn3', 'turn4']
['turn1', 'turn2', 'turn3', 'turn4', 'turn5']
['turn2', 'turn3', 'turn4', 'turn5']
['turn2', 'turn3', 'turn4', 'turn5', 'turn1']
None
['turn2', 'turn3', 'turn4', 'turn5', 'turn1', 'new']

So this is interesting, we can see 'append' and 'pop' working correctly until I try to create a new list that is the Donnington list with an appended element and when we print that list. It does show that an element was appended but it doesn't display the name nor that it is part of the list. However, when I go to print the original Donnington list, it appears that the added element displayed the way I thought it would in the new list. I guess what this means is that the attributes of append only apply to the list they refer to and the information that something was appended appear on a new list with the appended list being a part of but it doesn't show the appended element being added the way it was written to be. 

PAGE 80/50

So we're back to translating this part of the code:	

SHELL
_____
if have_ingredients[0] == True:
... have_ingredients[0] = False

- So were dealing with an 'if...' statement so we know the first statement 'if have_ingredients[0] == True:' which I imply to mean that is there is something in the first position of the list 'have_ingredients' then evaluate the next line so lets see if that is true with a test

SHELL
_____
NewList = ["thing1","thing2","thing3"]
print (NewList)
if NewList[0] == True:
    print ("this should print because there is an element in that position")
	
TERMINAL
________
['thing1', 'thing2', 'thing3']

- So what I expected did not happen. I thought because there was an element in NewList[0] that that would make the statement involving == to be true but that is not the case. I'm not sure how to print out that value in the terminal either so lets figure that out. It would seem that the first element of my list is false but I don't understand why that is the case. 

I asked the question in the Python Discord: https://discord.gg/python
Received the following:

List Truth Discrepancies_____________________________________________________________________________
TenOfHearts
OP
 — Today at 10:47 AM
How can this be the case?

The list passes truth with the 'all()' operator but none  of the individual elements pass?
Image
Python
 pinned 
a message
 to this channel. See all 
pinned messages
.
 — Today at 10:47 AM
Python
BOT
 — Today at 10:47 AM

Python help channel opened
Remember to:
• Ask your Python question, not if you can ask or if there's an expert who can help.
• Show a code sample as text (rather than a screenshot) and the error message, if you've got one.
• Explain what you expect to happen and what actually happens.

For more tips, check out our guide on asking good questions.
Closes after a period of inactivity, or when you send !close.
Avongard — Today at 10:48 AM
all checks for truthiness, so would be the equivalent of if Newlist[0]: without the == True 
For strings, they are considered true as long as they aren't empty ""
TenOfHearts
OP
 — Today at 10:51 AM
Right, so if the strings are true unless they are empty shouldn't 'if NewList[0] == True:' pass the truth test and print "something is false"?
Also I appreciate you taking the time to help me with this very much!
Avongard — Today at 10:53 AM
When you do == True it is different and checks that the value is the exact object True
You usually want to avoid using == True since when you have boolean or truthy values, the value itself already is True/False (and can and should just use if variable:), the one exception is if you want to know if the object is a literal True value
TenOfHearts
OP
 — Today at 10:54 AM
I thought so! So it false because it is not True exact verbatim, anything other than True should fail == True then correct?
Avongard — Today at 10:54 AM
Exactly
From the pep8 style guide:
Don’t compare boolean values to True or False using ==:
# Correct:
if greeting:
# Wrong:
if greeting == True:
Worse:

# Wrong:
if greeting is True:

And for checking if something is False, you should use if not greeting:
TenOfHearts
OP
 — Today at 10:57 AM
Just one last question:

if fridge_contents[“pepper”] > omelet_ingredients[“pepper”]:
... if have_ingredients[0] == True:
... have_ingredients[0] = False
... have_ingredients.append(“pepper”)
...
>>> if fridge_contents[“cheese”] > omelet_ingredients[“cheese”]:
... if have_ingredients[0] == True:
... have_ingredients[0] = False
... have_ingredients.append(“cheese”)
...
>>> if fridge_contents[“milk”] > omelet_ingredients[“milk”]:
... if have_ingredients[0] == True:
... have_ingredients[0] = False
... have_ingredients.append(“milk”)
...
>>> if have_ingredients[0] == True :
... print “I can make an omelet now”
...
I can make an omelet now

This is the piece of code I'm trying to understand and I'm not understanding why they are making the ==True comparison that way in the first place, it should pass the next line so it seems pointless
Image
That formatted incorrectly
Avongard — Today at 10:59 AM
!code
Python
BOT
 — Today at 10:59 AM
Here's how to format Python code on Discord:

```py
print('Hello world!')
```

These are backticks, not quotes. Check this out if you can't find the backtick key.
Avongard — Today at 11:00 AM
Yeah, they could just do have_ingredients[0] = False since its either already False (and will do nothing) or its True and will set it to false like they want
TenOfHearts
OP
 — Today at 11:00 AM
Alright, I appreciate the help tremendously!
Avongard — Today at 11:00 AM
Its a little weird to have a list that starts with a True/False followed by a bunch of ingredient strings... I'd advise having the true/false in its own variable instead of starting the list
In generally, its best to have lists where all the items are the same type if you can
________________________________________________________________________________________________
_ So what we've learned is the book is wrong and maybe I need to derive my own way of completing the functions mentioned in the book

At this point I feel like I'm wasting time trying to clarify something I don't get and they aren't even working in the book so I think I should move on 

83/53

If you use 'break', it will only take you out of the most recent loop, if you have a 'while...:' loop that contains a 'for...in...:' loop indented within it, a 'break' within the 'for...in...:' will not break out of the "while...:' loop. Both 'while...:' and 'for...in...:' loops can have an 'else:' statement at the end of the loop, but it will be run only if the loop doesn't end due to a 'break' statement. In this case 'else:' could be better named something like 'done' or 'on_completion' but 'else:' is a convenient name because you've already seen it, and it's not hard to rememeber. 

TRY IT OUT: USING ELSE WHILE REPEATING

SHELL
_____
for food in ("pate","cheese","crackers","yogurt"):
    if food == "yogurt":
        break
else:
    print ("there is no yogurt")

for food in ("pate","cheese","crackers"):
    if food == "yogurt":
        break
else:
    print ("there is no yogurt")

TERMINAL
________
there is no yogurt

- So basically this works fine, but I'm not really all that comfortable with the 'for...in''':' loops and I don't want to get back and review but I think that is neccesary. I feel like I'm losing a lot of time today reviewing, but as we cover more of these topics sometimes the intricacies of why things occur requires a detailed review of smaller parts of these concepts I may have missed the first time around because I didn't know to be looking out for them.

'for...in...:' - In the first part, the 'for...', you provide a name that you will use inside of the indented code. In the second part, the 'in...:' part, you provide a sequence, such as a list or tuple, which takes each --------------   element and assigns the value of the element to the name you provided in the first part. This saves you some of the effort that went in to using the 'while' loop in showing the omelet ingredients being put together:

SHELL
_____
omelet_ingredients={"cheese":1,"steak":2,"eggs":3,"mushroom":4,"milk":5}
ingredients=omelet_ingredients.keys()
for ingredients in omelet_ingredients.keys():
    print ("adding %d %s to the mix" % (omelet_ingredients[ingredients],ingredients))
	
TERMINAL
________
adding 1 cheese to the mix
adding 2 steak to the mix
adding 3 eggs to the mix
adding 4 mushroom to the mix
adding 5 milk to the mix

- So it seems what I'm missing from the 'for...in...' loop is that it will make and name a loop, lets see if that is the case: 

SHELL
_____
for dice in ["dice1","dice2","dice3"]:
    print (dice)

TERMINAL
________
dice1
dice2
dice3

- So that is interesting, what I was expecting to be printed was the actual list of dices as it is referred to in the 'in...' portion of the but it printed out each element of the list on its own line and something more interesting happened when I started using '(dice[0;0])' it would print out pieces of the word dice on a new line. Let me see if I can figure out how to properly isolate characters from the strings within dice1 this way. 

SHELL
_____
for dice in ["dice1","dice2","dice3"]:
    print (dice)
print (dice[0:0])
print (dice[0:1])
print (dice[0:2])
print (dice[0:3])
print (dice[0:4])
print (dice[0:5])

print (dice[1:0])
print (dice[1:1])
print (dice[1:2])
print (dice[1:3])
print (dice[1:4])
print (dice[1:5])

TERMINAL
________
dice1
dice2
dice3

d
di
dic
dice
dice3


i
ic
ice
ice3

- So this is interesting, it appears that when using '<name>[x:x]' it will print pieces of the string but where it is strange is that '0' seems to refer to the last element in string with [0:5] culminating in 'dice3' being printed but when you switch to [1:x] It only prints from the first position in the last element on. That makes sense now that I'm looking at it. I wonder how you get it to refer to a whole different element.:

SHELL
_____
for dice in ["dice1","dice2","dice3"]:
    print (dice)
print (dice[2][1])

TERMINAL
________
dice1
dice2
dice3

	Traceback (most recent call last):
	File "/home/jdoodle.py", line 3, in <module>
    print (dice[2][1])
	IndexError: string index out of range

- Not sure but this is something to circle back on later 2230-2283

83/53

If you use 'break', it will only take you out of the most recent loop, if you have a 'while...:' loop that contains a 'for...in...:' loop indented within it, a 'break' within the 'for...in...:' will not break out of the "while...:' loop. Both 'while...:' and 'for...in...:' loops can have an 'else:' statement at the end of the loop, but it will be run only if the loop doesn't end due to a 'break' statement. In this case 'else:' could be better named something like 'done' or 'on_completion' but 'else:' is a convenient name because you've already seen it, and it's not hard to rememeber. 


HOW IT WORKS
In each example, there is a test to determine whether there is any yogurt. If there is, the 'while...:' is terminated by using 'break'. However, in the second loop, there is no yogurt in the list, so when the loop terminates after reaching the end of the list, the 'else:' condition is invoked. There is one other commonly used feature for loops, the 'continue' statement. When continue is used, you're telling Python that you do not want the loop to be terminated, but that you want to skip the rest of the current repetition of the loop, and if you're in a 'for...in...:' loop, re-evaluate the conditions and the list for the next round. 

*'continue' -  you're telling Python that you do not want the loop to be terminated, but that you want to skip the rest of the current repetition of the loop, and if oyu're in a 'for...in...:' loop, re-evaluate the conditions -------------    and the list for the next round. 

TRY IT OUT: USING CONTINUE TO KEEP REPEATING

SHELL
_____
for food in ("pate","cheese","rotten apple","crackers","whip cream","tomato soup"):
    if food[0:6] == "rotten":
        continue
    print ("Hey, you can eat %s" % food)
	
TERMINAL
________
Hey, you can eat pate
Hey, you can eat cheese
Hey, you can eat crackers
Hey, you can eat whip cream
Hey, you can eat tomato soup

SHELL
_____
for dogs in ("saint bernard","dachshund","pitbull","boxer","golden retreiver"):
    if dogs[0:4] == "boxer":
        continue
    print ("I really like %s pups" % dogs)
	
TERMINAL
________
I really like saint bernard pups
I really like dachshund pups
I really like pitbull pups
I really like boxer pups
I really like golden retreiver pups

SHELL
_____
for dogs in ("saint bernard","dachshund","pitbull","boxer","golden retreiver"):
    if dogs[0:6] == "boxer":
        continue
    print ("I really like %s pups" % dogs)
	
TERNIMAL
________
I really like saint bernard pups
I really like dachshund pups
I really like pitbull pups
I really like golden retreiver pups

- This makes the example that even though there are quotes around two words in a string Python still looks at each word as a string on it own. So this looks like it has 4 strings but actually Python is reading that as six, each indivdual word can be referred to.

HOW IT WORKS 
Because you've used an 'if...:' test to determine wheather the first part of each item in the 'food' list contains the string "rotten apples" element will be skipped by the continue, whereas everything else is printed as safe to eat. 

HANDLING ERRORS
YOu have seen examples of how Python reports errors in CHapter 2 and Chapter 3. Those errors uaully contain a lot of information pertaining to what failed and how:

SHELL
_____
fridge_contents = {"eggs":8,"mushroom":20,"pepper":3,"cheese":2,"tomato":4,"milk":13}
if fridge_contents["orange juice"] > 3:
    print ("sure, lets have some juice")
	
TERMINAL
________
Traceback (most recent call last):
  File "/home/jdoodle.py", line 2, in <module>
    if fridge_contents["orange juice"] > 3:
KeyError: 'orange juice'

Opps, there is no orange jouic in the fridge right now, but it would be nice to be able to learn this without having to crash out the program.. You have already learned one way to find out about the keys thar are present in a dictionary and then searching through the list of keys to that are present in a dictionary, by using the key method of the dictionary and then seraching through the list of keys to determine whether the key you want is present. However, there's no reason not to take a shortcut. The last line of the error shown in the preceding code is 'KeyError: 'orange juice''. This says that the error Python encountered was an error with the key in the 'fridge_contents' dictionary. YOu can use the error that Python has told you about to brace the program against that paticular class of error. You do thiswith the special word 'try', telling Python prepare for an error

'try' - tells Python to prepare for an error

TRYING THINGS OUT
A 'try:' statement sets up a situation up in which an 'except:' statement can follow it. Each 'except:' statement handles the error, which is formally named an exception, that was just 'raised' when Python evaluated the code within the try: statement instead of failing. To start with, use 'except:' to handle one type of error, for instance, the KeyError that you get when trying to check the fridge. You have only one line in which to handle the error, which may seem restrictive, but in Chapter 5 you'll learn how to write your own functions so that you can handle error with more flexibitlity:

'exception' - The formal name for an error. 

SHELL
_____
fridge_contents = {"eggs":8,"mushroom":20,"pepper":3,"cheese":2,"tomato":4,"milk":13}
try:
    if fridge_contents["orange juice"] > 3:
        print ("sure, lets have some juice")
except KeyError:
    print ("Aww, there's no juice. Let's go shopping")
	
TERMINAL
________
Aww, there's no juice. Let's go shopping

You may find that you need to print more information about the error itself, and this is the information that you have access to. There are multiple kinds of exceptions, and each one's name reflects the problem that's occured and, when possible, the condition under which it can happen. Because dictionaries have keys and values, the KeyError indicates that the key that was requested from a dictionary isn't present. Similarly, a TypeError indicates that while Python was expecting one type of data, such as a string or an integer, another type was provided that can't do what's needed. In addition, when an exception occurs, the message that you would have otherwise seen when the program stops (when you run interactively) can be assessed. When you've learned more, you'll be able to define your own types of exceptions for conditions that require it. 

TRY IT OUT: CREATING AN EXCEPTION WITH IT EXPLAINATION - This is in Python 2 

SHELL
_____
fridge_contents = {"eggs":8,"mushroom":20,"pepper":3,"cheese":2,"tomato":4,"milk":13} ---
try:																					|
    if fridge_contents["orange juice"] > 3:												|
        print ("sure, lets have some juice")											|
except KeyError, (error):													       THIS IS BROKEN (Works in Python 2)
    print ("wow, there is no %s" % error)												|
																						|
TERMINAL																				|
________																				|
  File "/home/jdoodle.py", line 5														|
    except KeyError, (error):															|
                   ^																	|
SyntaxError: invalid syntax--------------------------------------------------------------

HOW IT WORKS
Because there is no key in fridge_contents dictionary for "orange juice", a KeyError is raised by Python to let you knwo that no such key is available. In addition, you specified the name error, which Python will use to reference a string that contains any information about the error that Python can offer. In this case, the string relates to the key that was requestion but not present in the fridge_contents dictionary. There may be times when you handle more than one type of error in exactly the same way: and in those cases, you can use a tuple with all of those 'exceptions' types described. 

- The issue that exists above is something that works in Python 2 but doesn't work in three, you may want to find out why. I would continue this part and really the rest of the course as you have. Just try things failing in both versions.

If you have an exception that you need to handle, but you want to handle it by not doing anything (for cases in which failure sin't actually a big deal), Python will let you skip that case by using the special word 'pass'. 

It was brought to my attention in the discord that this resource is too old to really be effective and I need to be learning from something more up to day so I'm going to start from here forward using a book called "Byte of Python" which is aimmed at beginners and mentioned in the Discords materials

START A BYTE OF PYTHON

- But first another recommendation from Socradeez in the Python Discord:

FOLLOW THIS CURRICULUM:

Google: "geeksforgeeks <item>" where each items is a piece of the curriculum 

SYLLABUS
--------
#"" refers to how 'socrates' user sent to me vs. the article names
- you'll notice at the bottom of each topic there is a long list of related items. Use that as another layer of study material per subject matter.
[X] Receiving Input
[X] Type Conversion
[X] Strings
[X] Formatted Strings
[X]String Methods
[X]Math Operations
    [X]Mathematical Functions (Set 1)
    []Mathematical Functions (Set 2)
    []Mathematical Functions (Set 3)
    []Mathematical Functions (Set 4)
[X]If Statements
[X]"Logical Operators" - Python Operators
[X] "Comparison Operators" - Relational Operators in Python
[X] While Loops
[X] Logical Not
[X] For Loops
*[X] Nested Loops (revisit this)
[X] Lists
*[X] Python | Using 2D arrays/list the right way
[X] List Methods in Python
[X] Python Tuples
[X] Python Dictionary
[] Python Functions
[] Parameters/Arguments
[] Return Statement
[] Exceptions
[] Comments
[] Generating Random Values
[] File Handling
[] Classes

FROM HERE STARTS GEEKSFORGEEKS MATERIAL------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TAKING INPUT IN PYTHON ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Developers often have a need to interact with users, either to get data or to provide some sort of result. Most programs today yse a dialon box as a way of asking the user to provide some type of input. While Python provides us with two inbuilt functions to read the input from the keyboard.

'input(prompt)'
'raw_input(prompt)'

'input()' - This function first takes the input from the user and converts it into a string. The type of the returned object always will be <type 'str'>. It does not evaluate the expression it just returns the complete statments as String. For example, Python provides a buil-in function called input which takes the input from the user. When the input function is called it stops the program and waits for the user's input. When the user presses enter, the program resumes and returns what the user typed

SYNTAX:

inp = input('STATEMENT')

SHELL
_____
>>> name = input('what is your name?\n')
>>> 

TERMINAL
________
>>> what is your name?
>>> <userinsertedname>

EXAMPLE - 9.89secs
SHELL
_____
val=input("enter value: ")
print(val)

TERMINAL
________
enter value: value1
value1


- An issue with the IDE you are using is making sure you turn the interactive terminal on, especially for the way this class in starting because you are already printed values that need user input for returns. Pretty cool.

HOW THE INPUT FUNCTION WORKS IN PYTHON 
+ When 'input()' function executes, program flow will be stopped until the user has given input. - using 'input()' operator stops the program until the user puts something in and that value can then be used in the program. Given that it stops the program it should operate as a sort of break in a looping sequence from what I understand at this point.+ The text or message displayed on the output screen to ask a user to enter an input values is optional the prompt, which will be printed on the screen is optional. Whatever you enter as input, the input function converts converts it inot a string. If you enter an integer value still input() function converts it into a string. You need to explicitly convert it into an integer in you code using 'typecasting'

SHELL
_____
#Program to check input type in Python
num = input("enter number:")
print(num)
name1 = input("enter name:")
print(name1)

#printing type of input value
print("type of number", type(num))
print("type of name", type(name1))

TERMINAL
________
enter number:5
5
enter name:Bosco
Bosco
type of number <class 'str'>
type of name <class 'str'>

'raw_input():' - This function works in older versions like 2. This function takes exactly what is typed from the keyboard, converts it into a string, and then returns it to the variable in which we want to store it. 

- This was a really finicky operator for Python 2 to evaluate, I had to press enter and the IDE appeared to stop thinking and then it spit out the input request but when I put the name in it didn't think again and print it, the output just disappeared. This should probably be disregarded. 

Here , 'g' is a variable that will get the string value, typed by the user during the execution of the program. Typing of data for the rew_input() function is terminated by enter key. We can use raw_input() to enter numberic data also. In that case, we use ;typecasting'. For more details on typecasting refer: https://www.geeksforgeeks.org/taking-input-from-console-in-python/

SHELL
_____
num = int(input("enter a number: "))
print(num, " ", type(num))

floatNum = float(input("enter a decimal: "))
print(floatNum," ",type(floatNum))

TERMINAL
________
enter a number: 5
5   <class 'int'>
enter a decimal: 2.65
2.65   <class 'float'>

- If you don't enter in a decimal you will get an error because the type won't match float and float is what is being converted to string. You would have to specify the correct type according to expected input to avoid this error. 

- Wow that's the end of this course so lets review what we learned here. 

1. ) 'input()' - This operator asks the user for their input in the shell. It will print a string that is between the parentheses and it will stop the program until the user puts in the information required. That information is ------------   stored and the next operation can be run. In order to use the information though, you'll have to name is and recall the name. Here is an example:

SHELL
_____
callingname = input("what is your name: ")
print(callingname)

TERMINAL
________
what is your name: Doggie
Doggie

				and that is really all this chapter covered the 'input()' operator. This will accept and output the type according to the input of the user unlike raw_input() which will always return a string that has to be converted to another type. 
				
2.) 'raw_input()' - This is actually phased out of Python and if it is seen in code it should be replaced by 'input()'. Even when you try to use it in python 3 it will not recognize the operator. 

TYPE CONVERSION IN PYTHON
Python defines type converstion functions to directly convert one data type to another which is useful in day-to-day and competitive programming. This aricle is aimed at providing information about certain conversion functions. There are two types of Type Conversion in Python:

1. Implicit Type Conversion
2. Explicit Type Conversion

Lets discuss them in detail. 

IMPLICIT TYPE CONVERSION 
In Implicit type conversion of data types in Python, the Python interpreter automatically converts one data type to another without any user involvement. So this is like behind the scenes data conversion. To get a more clear view of topic see the below examples:

SHELL
_____
x = 10

print("x is of type",type(x))

y= 10.6
print("y is of type",type(y))

z = x + y
print(z)
print("z is of type",type(z))

TERMINAL
________
x is of type <class 'int'>
y is of type <class 'float'>
20.6
z is of type <class 'float'>

As we can see the data type of 'z' got automatically changes to the 'float' type while the other variable 'x' is of integer type while the oother variable 'y' is of float type. The reason for the float value not being converted into an integer instead is due to type promotion that allows performing operations by coverting data into a wide-sized data type without any loss of information. This is asimple case of Implicit Type Conversion in Python. 

'COMPETITIVE PROGRAMMING' - This is a mind sport usually held over the Internet or a local network, involving participants trying to program according to provided specifications. 
-------------------------

'TYPE PROMOTION' - he reason for the float value not being converted into an integer instead is due to type promotion that allows performing operations by coverting data into a wide-sized data type without any loss of ----------------   information.

INPUT_0225
- have to remember to make the shell 'interactive' with the terminal to get callback to work correctly

SHELL
HasToHavePrint = input("what needs to be printed?: ")
print (HasToHavePrint)

TERMINAL
what needs to be printed?: yo
yo

ELICIT TYPE CONVERSION ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.) 'int(a,base):' - This function converts any data type into an integer.'Base' specifies the base in which string is if the data type is a string
2.) 'float()' - This function is used to conver any data type to a floating-point number. 
3.) ord() - This function is used to convert a character into an integer
4.) hex() - This function is to convert integer
5.) oct() - This function is used to convert integer into octal string
6.) tuple() - This function is used to covert to a tuple
7.) set() - This function returns the type after converting to set
8.) list() - This function is used to convert any data to a list tuple
9.) dict() - this function is used to convert a tuple of order (key,value) into a dictionary
10.) str() - Used to convert integer into a string
11.) complex(real,imag) - this function converts real numbers to complex (real,imag) numbers
12.) chr(number) - This function converts numbers to is corresponding ASCII character

In Explicit Type Conversion in Python, the data type is manually changed bu the user as per their requirement. With explicit type converstion, there is a risk of data loss since we are focing an expression to be changed in some specific data type. Various forms of explicit type conversion are explained below:

1.) 'int(a,base):' - This function converts any data type into an integer.'Base' specifies the base in which string is if the data type is a string
2.) 'float()' - This function is used to conver any data type to a floating-point number. 

' BASE 2 ' - This indicates that something is binary. Base two only has 0's and

SHELL
_____
#Python code to demonstrate Type Coversion
#using int(), float()

#making string
s = "10010"

#printing string converting to int base 2
c =int(s,2)
print ("after converting to integer base 2: ", end="")
print (c)

#printing string converting to float
e = float(s)
print ("after covering to float : ", end="")
print(e)

TERMINAL
________
after converting to integer base 2: 18
after covering to float : 10010.0

3.) ord() - This function is used to convert a character into an integer
4.) hex() - This function is to convert integer
5.) oct() - This function is used to convert integer into octal string

SHELL
_____
#python code to demonstrate Type Conversion
#using ord(), hex(), oct()

#create integer (this is a string tho)
s = '4'
print (type(s))

#printing character converting to integer
c = ord(s)
print ("after converting character to integer : ",end="")
print (c)

#printing integer converting to hexadecimal
c = hex(56)
print ("after converting 56 to hexadecimal string : ",end="")

#printing integer coverting to octal string
c = oct(56)
print ("after converting 56 to octal string : ",end="")
print (c)

TERMINAL
________
<class 'str'>
after converting character to integer : 52
after converting 56 to hexadecimal string : after converting 56 to octal string : 0o70

_____________________________________________________________________________________________________________________

' end="" ' - Unlike '\n' which starts a new line below the line that uses it. '

- this 'end; feature is interesting, from what I understand 'end' ends the line it's on there and pulls the next line up to it which is helpful for like there a colon calls for something. You can write in on the line below and it will pull up to the line above. 

________________________________________________________________________________________________________________________

SHELL
_____
print ("there should be another string after the colon here : ", end="")
print ("this information should be after the colon")
print (" as opposed to the function that will put the answer after the colon on a new line : "\n)
print ("this should be after the colon but below the line")

- I'm trying to do this with \n but I clearly don't know how to use that properly so I'm going to look it up. 

SHELL
_____
print ("this is the first line")
print ("\nthis line will appear on the next line")
print ("\tthis line will be indented")
print ("\"this will put quotes in your string\"")

TERMINAL
________
this is the first line

this line will appear on the next line
	this line will be indented
"this will put quotes in your string"

- So I figured out quite a few little tricks to modify the printed text there lets try the original one then move on. I got it this time:

SHELL
_____
print ("this line should have the next line print after the colon : ", end="")
print ("this is the line behind the colon")
print ("this line should have the next line under the colon : ")
print ("\nthis line should be under the colon")

TERMINAL
________
this line should have the next line print after the colon : this is the line behind the colon
this line should have the next line under the colon : 

this line should be under the colon


6.) tuple() - This function is used to covert to a tuple
7.) set() - This function returns the type after converting to set
8.) list() - This function is used to convert any data to a list tuple

' set() ' - Sets are used to store multiple items in a single variable. Set is one of 4 built-in data types in Python used to store collections of fata, the other 3 are List, Tuple, and Dictionary. All with different qualities and usage. A set is a collection which is unordered, unchangeable, and unindexed. Set ITEM are unchangable but you can add and remove items

shell
-----

 #python code to demonstrate type Conversion
#using tuple(), set(), list()

#initializing string
s = 'geeks'

#printing string converting to tuple
c = tuple(s)
print ("after coverting string to set : ",end="")
print (c)

#printing string converted to set
c = set(s)
print ("after converting string to set : ", end="")
print (c)

#printing string converting to list
c = list(s)
print ("after converting string to list : ",end="")
print (c)

term
----
after coverting string to set : ('g', 'e', 'e', 'k', 's')
after converting string to set : {'e', 'g', 'k', 's'}
after converting string to list : ['g', 'e', 'e', 'k', 's']

9.) dict() - this function is used to convert a tuple of order (key,value) into a dictionary
10.) str() - Used to convert integer into a string
11.) complex(real,imag) - this function converts real numbers to complex (real,imag) numbers

shell
-----

#python code to demonstrate Type Conversion
#using dict(), complex(), str()

#initializing tuple
tup = (('a',1),('f',2),('g', 3))
print (tup)

#initializing integers
a = 1
b = 2

#printing integer converting to complex number
c = complex(1,2)
print("after converting integer to complex number : ",end="")
print(c)

#printing integer converting to a string
c = str(a)
print ("after converting integer to string : ",end="")
print (c)

#printing tuple converting to expression dictionary
c = dict(tup)
print ("after converting tuple to dictionary : ",end="")
print (c)

term
----

(('a', 1), ('f', 2), ('g', 3))
after converting integer to complex number : (1+2j)
after converting integer to string : 1
after converting tuple to dictionary : {'a': 1, 'f': 2, 'g': 3}

12.) chr(number) - This function converts numbers to is corresponding ASCII character

shell
-----
#convert ASCII value to characters
a = chr(76)
b = chr(77)

print (a)
print (b)

term
----
L
M

_ That is the conclusion on that lesson, we're learning some thing but I'm not really applying it like I forgot what we learned yesterday. That was inputs, so maybe let me combine that so I make a string that asks for an input and then skip a line print the answer then convert the answer to a corresponding type. At this point that is the assignment convert the inputted information to all 12 types according to what they can do to make sure you understand how to convert information you didn't put in.

- It's monday and I need a refresher on both. Working on that now.

TYPE CONVERSION_0227_1200

SHELL
A = 12.5556
int(A,2)
print (A)

TERMINAL
Traceback (most recent call last):
  File "/home/jdoodle.py", line 2, in <module>
    int(A,2)
TypeError: int() can't convert non-string with explicit base

- The error is telling us we need to use a string for this so lets try that:

SHELL
A = "family"
int(A,2)
print (A)
print (type(A))

TERMINAL
Traceback (most recent call last):
  File "/home/jdoodle.py", line 2, in <module>
    int(A,2)
ValueError: invalid literal for int() with base 2: 'family'

- That didn't work either so maybe it has to convert from a large number that can be based down to what is specified, lets try that:

SHELL
A = 65233232
int(A,2)
print (A)
print (type(A))

TERMINAL
Traceback (most recent call last):
  File "/home/jdoodle.py", line 2, in <module>
    int(A,2)
TypeError: int() can't convert non-string with explicit base

- That didn't work either so I checked the lesson and it shows the number entered as a string so lets try that, that also doesn't work but I did find something that did, for base 2 the type converted has to be something that is a 'factor' of whatever base your using. So base 2 can only convert 1's and 0's:

SHELL
s = "10111010"
A = int(s,8)
print (A)
print (type(A))

TERMINAL
186
<class 'int'>

SHELL
s = "10111010"
A = int(s,8)
print (A)
print (type(A))

TERMINAL
2134536
<class 'int'>

- Additionally, I had to set the conversion to something too so to initialize you have to set a string of numbers that is a 'factor' of the base and then set the conversion to another variable that can be referenced in the print commamds 

PYTHON STRING --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
A string is a data structure in Python that represents a seqeunce of characters. It is an immutable data typel meaning that once you have created a string, you cannot change it. Strings are used widely in many different applications, such as storing and manipulating text data, representing names, addressesm and other types of data that can be representd as text. EXAMPLE:

	"Geekforgeeks" or 'Geeksforgeeks'
	
Python doesn not have a character data type, a single character is simply a string with a length of 1. Square brackets can be used to access elements of the string

SHELL
print (" a computer science portal for geeks")

TERMINAL
 a computer science portal for geeks
 
CREATING A STRING IN PYTHON
Strings in Python can be created using single quote or a double quote or even triple quotes
 
SHELL___
String1 = 'Welcome to the Geeks World'
print("String with the use of single quotes: ")
print(String1)

TERMINAL
String with the use of single quotes: 
Welcome to the Geeks World


SHELL___
String1 = "I'm a Geek"
print("\nString with the use of Double Quotes: ")
print(String1)

TERMINAL
String with the use of Double Quotes: 
I'm a Geek


SHELL___
String1 = '''I'm a Geek and I live in a world of "Geeks"'''
print("\nString with the use of Truple Quotes: ")
print(String1)

TERMINAL
String with the use of Truple Quotes: 
I'm a Geek and I live in a world of "Geeks"


SHELL___
String1 = '''Geeks
            For
            Life'''
print ("\nCreating a multiline string: ")
print(String1)

TERMINAL
Creating a multiline string: 
Geeks
            For
            Life

In Python, individual characters of a String can be accessed by using the method of Indexing. Indexing allows negative address references to access characters from the back of the String, e.g. -1 refers to the last character, - 2 refers to the second to last character, and so on. While accessing an index out of the range will cause and IndexError. Only Integers are allow to be passed as an index, float or other types that will cause a TypeError. 

SHELL
String1 = "GeeksforGeeks"
print("Initial String: ")
print(String1)

print("\nFirst character of the string is: ")
print(String1[0])

print("\nLast character of String is: ")
print(String1[-1])

TERMINAL
Initial String: 
GeeksforGeeks


First character of the string is: 
G

Last character of String is: 
s

REVERSING A PYTHON STRING 
With accessing characters from a string, we can also reverse them. We can reverse a string by writing [::-1] and the string will be reversed:

	SHELL___
	gfg = "geeksforgeeks"
	print(gfg[::-1])

	TERMINAL
	skeegrofskeeg
	
We can also reverse a string by using built-in join and reversed function:

	SHELL___
	gfg = "geeksforgeeks"
	gfg = "".join(reversed(gfg))

	print(gfg)
	
	TERMINAL
	skeegrofskeeg
	
STRING SLICING
To access a range of character in the String, the method of slicing is used. Slicing in a String is done by using a Slicing operator (colon):

	SHELL___
	String1 = "GeeksForGeeks"
	print("Initial String: ")
	print(String1)

	print("\nSlicing characters from 3-12: ")
	print(String1[3:12])

	print("\nSlicing characters between "+ "3rd and 2nd last character: ")
	print(String1[3:-2])

	TERMINAL
	Initial String: 
	GeeksForGeeks
	

	Slicing characters from 3-12: 
	ksForGeek

	Slicing characters between 3rd and 2nd last character: 
	ksForGee
	
DELETING/UPDATING FROM A STRING
In Python, updation or delevtion of characters from a string is not allowed. This will cause an error because item assignment or item deletion from a String is not supported. Although deletion of the entire String is possible with the use of a built-in del keyword. This is because Strings are immutable, hence elements of a String cannot be changes once it has been assigned. Only new strings can be reassigned to the same name. Updation of a character:

[] ' .join ' - This method takes all items in an iterable and joins them into one string. This is interesting because it will just smash the elements together unless a character to separate each one is specified but even 
------------   when smashing them together you will need atleast a ' "".join(string) ' empty quote to let the operation know to separate each element with nothing. 
	SHELL___
		JoinMethod = ("these","strings","will","join")
		JoinedString = ",".join(JoinMethod)
		print (JoinedString)

		MessyJoinMethod = ("these","strings","will","join")
		MessyJoinedString = "".join(JoinMethod)
		print (MessyJoinedString)
		
	TERMINAL
		these,strings,will,join
		thesestringswilljoin

' iterable ' - An object which can be looped over or iterated over with the help of a for loop. Objects like lists, tuples, sets, dictionaries, strings, are called iterables. In short and simpler terms, iterable is anything
------------   you can loop, over and over again. 

' (reversed) ' - 

SHELL___
String1 = "Hello, I'm a Geek"
print("Initial String: ")
print(String1)

list1 = list(String1)
list1[2] = 'p'
String2 = ''.join(list1)
print("\nUpdating character at 2nd Index: ")
print(String2)

String3 = String1[0:2] + 'p' + String1[3:]
print (String3)

TERMINAL
Initial String: 
Hello, I'm a Geek

Updating character at 2nd Index: 
Heplo, I'm a Geek
Heplo, I'm a Geek


- At this point this does introduce alot of concepts I'm not familiar with and I really feel like I need to combine these to get what going on to this point so lets name our subjects so far:

[]SINGLE QUOTE STRING
	SHELL___
		print('this is a string with single quotes')
	
	TERMINAL
		this is a string with single quotes
	
	
[]DOUBLE QUOTE STRING
	SHELL___
		print("this is a string with double quotes")
	
	TERMINAL
		this is a string with double quotes
	
	
[]TRIPLE QUOTE STRING
	SHELL___
		print ('''this is a string with triple quotes''')
	
	TERMINAL
		this is a string with triple quotes
	
	
[]MULTILINE STRING
	SHELL___
		print (''' Multiple
				Lines
				Have
				Triple
				quotes''')
			
	TERMINAL
		Multiple
				Lines
				Have
				Triple
				quotes

[]REVERSE STRING
	
	SHELL____
		reversereverse = "donkey"
		print(reversereverse[::-1])
	
	TERMINAL
		yeknod
	
[]SLICE STRING

	SHELL___
		AboutToSliceThis = "string"
		print (AboutToSliceThis[3:12])
	
	TERMINAL
		ing

 Okay I'm trying to better organize everything I've learned about Python into something I can refer to quickly and organizing this is difficult. So far I've chosen to name a concept and then show the SHELL and TERMINAL text with as much explanation in the code as possible for every concept so far that can be represented within that 'SHELL | TERMINAL' format. It seems the first step is to go through this list and recognize each concept that can apply to before creating the list. That list should also be able to be directly changed into a test. Starting on that part now. The concept that need to be displayed will have a [] next to them like your life list and an X needs to be added to them when they have made it over to the Standard Self Reference.
 
 [] At some point you may want to go through and reformat the code written in this to reflect this format:
 
	SHELL___
		<code>
		
	TERMINAL
		<output>
		
DELETING AND UPDATING A STRING (Recap)________________________________________________________________________________________________________________________
You can delete a string with the ' del ' keyword. In Python, Updation or deletion of characters from a String is not allowed. This will cause an error because item assignment of item deletion from a string is not supported. Although deletion of the entire String is possible with the use of a built-in ' del ' keyword. This is because Strings are immutable, hence elements of a String cannon be changed once it has been assigned. Only new strings can be reassigned to the same name. You can also update a charater of a string or the entire string. Updating a character doesn't work in Python.

- Thinking about my career, the business did say it would be in my interest to post to LinkedIn everyday just to continue to gain a following and make sure I'm active in the at area. Thinking up content to post is a bit of a hassle though. I'll just put that on my todo list and figure it out at home. 

[]UPDATING STRING
	SHELL___
		StringOne = ("hi, I'm a geek")
		print(StringOne)

		StringOne = ("welcome to the geek world")
		print(StringOne)
	
	TERMINAL
		hi, I'm a geek
		welcome to the geek world
		
[]DELETING STRING
	SHELL___
		StringOne = ("hi, I'm a geek and StringOne has printed")
		print(StringOne)

		print("\nStringOne has been deleted so there should be an error when trying to print it: ")
		del StringOne
		print(StringOne)
	TERMINAL
		hi, I'm a geek and StringOne has printed

		StringOne has been deleted so there should be an error when trying to print it: 

			Traceback (most recent call last):
			File "/home/jdoodle.py", line 6, in <module>
			print(StringOne)
			NameError: name 'StringOne' is not defined

[]DELETING CHARACTER 
	SHELL___
		StringOne = (" I want to delete a character")
		print(StringOne)

		StringTwo = StringOne[0:18]+StringOne[19:]
		print(StringTwo)
	TERMINAL
		I want to delete a character
		I want to delete  character
		
- You cannot update a charater in Python

ESCAPING SEQUENCING IN PYTHON________________________________________________________________________________________________________________________________
While printing STRINGS with single and double quotes in it causes SyntaxError because String already contains Single and Double Quotes and hence cannot be printed with the use of either of these. Hence, to print such a String either Triple Quotes are used or Escape sequences are used to print such Strings. Escape sequences start with a backslash and can be interpreted differently. If single quotes are used to represent a string, the all the single quotes present in the string must be escaped and same is done for Double Quotes. Not sure why they used a string that had an apostrophe in it to show single quotes then put the double quotes up against the end of the string, that is incredibly misleading. I'm going to try and make them aware of that. I'm extrememly frustrated with that choice on their part. I'll use single quotes to the best of my understanding. What is looks like it that you use single quotes for the string as you would normally then you can use a backslash where you need to escape and any where between that backslash and the ending single quotes you can use double quotes and they will print as double quotes in the string. To ignore the escape sequences in a STRING, ' r ' or ' R ' is used, this implies that the STRING is a raw string and escape sequences inside it are to be ignored. 

[]ESCAPE QUOTES
	SHELL___
		EscapeSingleQuotesDoubleQuotes = 'the entering of \"backslash, doublequote" will open double quotes existing in a single quote string'
		print(EscapeSingleQuotesDoubleQuotes)

		EscapingDoubleQuotesSingleQuotes = "\nthe entering of \'backslash, singlequote' will open double quotes existing in a single quotes string"
		print(EscapingDoubleQuotesSingleQuotes)

		EscapingTripleQuotesSingleQuotes = '''\nthe entering of \'backslash, singlequote' will open single quotes existing in a triple quote string'''
		print(EscapingTripleQuotesSingleQuotes)
	TERMINAL
		the entering of "backslash, doublequote" will open double quotes existing in a single quote string

		the entering of 'backslash, singlequote' will open double quotes existing in a single quotes string

		the entering of 'backslash, singlequote' will open single quotes existing in a triple quote string
		
[]IGNORE SEQUENCES
	SHELL___
		EscapeSequencesPresent=("this string \nHas a bunch of Escape \n\tSequences that are going to be \'ignored' by raw\n")
		print(EscapeSequencesPresent)
		EscapeSequencesRaw=(r"this string \nHas a bunch of Escape \n\tSequences that are going to be \'ignored' by raw")
		print(EscapeSequencesRaw)
		print("\nRAW is just a simple ' r ' before the quotations in a string")
	TERMINAL
		this string 
		Has a bunch of Escape 
			Sequences that are going to be 'ignored' by raw

	this string \nHas a bunch of Escape \n\tSequences that are going to be \'ignored' by raw

	RAW is just a simple ' r ' before the quotations in a string
	
FORMATTING STRINGS ' "{}{}".format('<string>','<string>') ________________________________________________________________________________________________________
String in Python can be formatted with the use of ' format() ' method which is a very versatile and powerful tool for fomatting STRINGS. Format method in Strings contains curly braces{} as placeholders which can hold arguments according to position or keyword to specify the order. Integers such as Binanry, hexadecimal, etc. and floats can be rounded or displayed in the exponent form with the use of format specifiers. A string can be left() or center(^) justified with the use of format specifiers, separated by a colon(:)

[]STRING FORMAT
	SHELL___
		NormalOrder= ("{} {} {}".format('zero','one','two'))
		print("This is the default order: ")
		print(NormalOrder)

		PositionalOrder=("{2} {2} {0}".format('zero','one','two'))
		print('\nThis is the positional order \" (2) (2) (0) ": ')
		print(PositionalOrder)

		KeywordOrder=("{z} {t} {o}".format(z='zero',o='one',t='two'))
		print('\nThis is the Keyword Order \"{z} {t} {o}": ')
		print(KeywordOrder)
	
	TERMINAL
		This is the default order: 
		zero one two

		This is the positional order " (2) (2) (0) ": 
		two two zero

		This is the Keyword Order "{z} {t} {o}": 
		zero two one
		
[]BINARY FORMAT
	SHELL___
		BinaryFormattingInt= "\n{0:b}".format(200)
		print('\" {0:b}.format(<anumber>) " \nchanging 200 to BINARY: ')
		print (BinaryFormattingInt)
		
	TERMINAL
		" {0:b}.format(<anumber>) " 
		changing 200 to BINARY: 

		11001000
		
[]EXPONENT FORMAT
	SHELL___
		ExponentFormattingFloat= ("\n{0:e}".format(200.2222222222))
		print('\" {0:e}.format(<afloat>) " \nChanging 200.2222222222 to an EXPONENT: ')
		print(ExponentFormattingFloat)
		
	TERMINAL
		" {0:e}.format(<afloat>) " 
		Changing 200.2222222222 to an EXPONENT: 

		2.002222e+02
		
[]ROUNDING FLOATS
	SHELL___
		RoundedFloatOnePosition =("\n{0:.1f}".format(2/3))
		print('\"{0:<positions>f}".format(<anumber>/<anumber>)')
		print("dividing 2 by 3 with one position after the decimal: ")
		print(RoundedFloatOnePosition)

		RoundedFloatTwoPositions =("\n{0:.2f}".format(2/3))
		print('\n\"{0:<positions>f}".format(<anumber>/<anumber>)')
		print("dividing 2 by 3 with two positions after the decimal: ")
		print(RoundedFloatTwoPositions)

		RoundedFloatThreePositions =("\n{0:.3f}".format(2/3))
		print('\n\"{0:<positions>f}".format(<anumber>/<anumber>)')
		print("dividing 2 by 3 with three positions after the decimal: ")
		print(RoundedFloatThreePositions)
	
	TERMINAL
		"{0:<positions>f}".format(<anumber>/<anumber>)
		dividing 2 by 3 with one position after the decimal: 

		0.7

		"{0:<positions>f}".format(<anumber>/<anumber>)
		dividing 2 by 3 with two positions after the decimal: 

		0.67

		"{0:<positions>f}".format(<anumber>/<anumber>)
		dividing 2 by 3 with three positions after the decimal: 

		0.667
		
- I think I need to start making more notes in my code, that last one just looks like three big ass blocks of text. I don't look at that and want to read it to figure out what is going on there so I need to do something to format this code in a more appealing manner. 


[]JUSTIFIED STRING
	SHELL___
		JustifiedString= ("|{:<10}|{:^10}|{:>10}|".format('left','middle','right'))
		print(JustifiedString)

		RightJustifiedString = ("\n|{:>10}|".format('right',''))
		print(RightJustifiedString)

		LeftJustifiedString = ("\n|{:<10}|".format('left',''))
		print(LeftJustifiedString)

		MiddleJustifiedString = ("\n|{:^10}|".format('middle',''))
		print(MiddleJustifiedString)
		
	TERMINAL
		|left      |  middle  |     right|

		|     right|

		|left      |

		|  middle  |
		

STRING FORMATTING IN PYTHON_________________________________________________________________________________
String formatting is the process of infusing things in the string dynamically and presenting the string. Ther are four different ways to perform string formatting in Python: formatting with the % operator, formatting with format() string method, formatting with string literals, called f-strings, formating with string template class. So we will see the entirety of the above-mentioned ways, and we will also focus on which string formatting is the best strategy. 

METHOD 1: FORMATTING STRING USING % OPERATOR
It is the oldest method of string formatting. Here we use the modulo % operator. The modulo % is also known as the string-formatting operator. You can also inject multiple strings at a time and can also use variable to inset your objects in the string. %s is used to inject string similarly '%d" for integers,%f for floating points, %b for binary format. For all formats, converstion methods visit the official documentation. 

[]PERCENT SIGN FORMATTING | Modulo %
	SHELL___
		print("%s already know how to do this" % ("we"))
		
	TERMINAL
		we already know how to do this
		
[]MULTIPLE PERCENT SIGN FORMATTING | Modulo %
	SHELL___
		FirstModuloString = 'this string has a name, its FirstModuloString'
		print("%s \nbut %s" % ("\nThis string doesnt have a name",FirstModuloString))
		
	TERMINAL
		This string doesnt have a name 
		but this string has a name, its FirstModuloString
		
[]INSERTING DIFFERENT OPERATOR FORMATS
	SHELL___
		print('this one is another %s replacement' % ('string'))
		print('\nbut this %d is a number and uses \"percent, d"' % (1))
		print('\nthis %i is also a number but uses \"percent, i"' % (1))
		print('\nthis %.02f uses a float with \"percent, f"' % (1.1111))
		print('\nnot so sure on this but \"percent, b" is supposed to be binary')
		
	TERMINAL
		this one is another string replacement

		but this 1 is a number and uses "percent, d"

		this 1 is also a number but uses "percent, i"

		this 1.11 uses a float with "percent, f"

		not so sure on this but "percent, b" is supposed to be binary
		
PLACEHOLDER FLOAT PRECISION
floating-point numbers us either format %a.bf. Here, ' a ' would be the minimum number of digits to be present in the string; these might be padded with white space if the whole number doesn't have this many digits. Close to this, bf represents how many digits are to be displayed after the decimal point. Like ' 5(digits).4(after the decimal)f ' would look like ' 5.4f '.

[] PLACEHOLDER FLOAT FORMAT | FLOAT PRECISION % SIGN
	SHELL___
		print("I'll use a random number out to 10 digits: %11.10f" % (3.14166820680974986712))
		
	TERMINAL
		I'll use a random number out to 10 digits: 3.1416682068
		
[] MULTIPLE FORMATS, SAME STRING
	SHELL___
		anumber = 24
		print("a number is: %d" % (anumber))
		StringOne = ("\nthe number as a variable: %d \nthe number as a float: %f" % (anumber,anumber))
		print(StringOne)
		
	TERMINAL
		a number is: 24

		the number as a variable: 24 
		the number as a float: 24.000000
		
METHOD 2: FORMATTING STRING USING FORMAT() METHOD
' Format() ' method was introduced with Python3 for handling complex string formatting more efficiently. Formatters work by putting in one or more replacement fields and placeholders defined by a pair of curly braces {} into a string and calling the ' str.format() '. The value we wish to put into the placeholders and concatenate with the string passed as parameters into the format function. Basically this is saying you can use curly brackets in a string to act as a placeholder and you can refer to what is supposed to be in that place with ' .format('<thestringinput>') '. The ' .format() ' method has many advantages over the placeholder method: - We can index curly format, we can assign keywords for insertion, We can reuse references to the same value multiple times, we can determine float precision with indexing as well. 

' concatenate ' - Link together in a chain or series

[] CURLY PLACEHOLDER METHOD 
	SHELL___
		print('this is a {} way to reference input in a string'.format('new'))
		
	TERMINAL
		this is a new way to reference input in a string
		
[] INDEX CURLY FORMATTING
	SHELL___
		print('{2} {1} {0}'.format('super','duper','uber'))
		
	TERMINAL
		uber duper super

[ Messing around with this I found a way to vary the input of the same string repeatedly with different values using % but it didn't work using the method above: ]
	SHELL___
		VariableNumberOne = 75
		VariableNumberTwo = 600
		VariableNumberThree = 245

		print("the current variables are: %s %s %s" % (VariableNumberOne,VariableNumberTwo,VariableNumberThree))
	TERMINAL
		the current variables are: 75 600 245

[] ASSIGNED KEYWORD FORMATTING
	SHELL___
		print('a:{a},b:{b},c:{c}'.format(a=1,b='two',c=3.54))
		
	TERMINAL
		a:1,b:two,c:3.54
		
[] MULTIPLE INSERT FORMATTING
	SHELL___
		print('three cheers for Thomas: {c} {c} {c}'.format(c='\ncheers!'))
		
	TERMINAL
		three cheers for Thomas: 
		cheers! 
		cheers! 
		cheers!
		
[] FLOAT PRECISION FORMAT
	SHELL___
		print('the selected value is: {0:1.2f}'.format(3.3210,2.333333,1.23456789))
		print('the selected value is: {1:1.2f}'.format(3.3210,2.333333,1.23456789))
		print('the selected value is: {2:1.2f}'.format(3.3210,2.333333,1.23456789))
		
	TERMINAL	
		the selected value is: 3.32
		the selected value is: 2.33
		the selected value is: 1.23
		
METHOD 3: FORMATTED STRING USING F-STRINGS
PEP 498 introduces a new string formatting mechanism know as Lister String Interpolation or more commonly as ' f-strings ', because the leading f character preceding the string literal. The idea behaind f-strings is to make string interpolation simpler. To create an f-string, prefix the string with the letter ' f '. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed Python expressions inside string literals for formattings. This new formatting syntax is very powerful and easy. You can also insert arbitrary Python expressions and you can even do Math opertations in it. We can also use ' lambda ' expressions in f-strings formatting.

' interpolation ' - the insertion of something of a different nature into something else, a remark interjected in a conversation.

' lambda ' - Python lambda functions are anonymous function means that the function is without a name. As we already know that the def keyword i used to define a normal function in Python. Similarly, the lambda keyword is used to define an anonymous function in Python.

[] F STRING FORMAT
	SHELL___
		filler='filled'
		print(f"this string is being {filler}")
		print(f"{filler} the string so this string is being {filler}")
		
	TERMINAL
		this string is being filled
		filled the string so this string is being filled
		
[] F STRING Math
	SHELL___
		a = 10
		b = 24

		print(f"using an f string to insert an equation with inputs a and b: \n{2*(a+b)}")
	TERMINAL
		using an f string to insert an equation with inputs a and b: 
		68

[] LAMBDA F STRING
	SHELL___
		print(f"he said his age is {(lambda x: x*2)(3)}")
		
	TERMINAL
		he said his age is 6
		
[ I have no idea how this shit works, I don't really understand it either. Maybe I should play with it. ]

[] FLOAT PRECISION F STRINGS
	SHELL___
		num = 1.54321
		print(num)
		print(f"\nthe value of num is: {num:{1}.{2}}")
		print(f"\nthe value of num is: {num:{1}.{3}}")
		
	TERMINAL
		1.54321

		the value of num is: 1.5

		the value of num is: 1.54
		
METHOD 4 :STRING TEMPLATE CLASS
[] Write down all the methods at the begginning of this passage so that they can all be accounted for uniquely
In the STRING module, Template Class allows us to create simplified syntax for output specification. The format uses placeholder names formed by $ with valid python identfiers (alphanumerica characters and underscores) Surround the place holder with braces allows it to be followed by more alphanumberic letters with no intervening spaces. Wrigint $$ creates a single escaped $.

[] FORMATTING WITH TEMPLATE CLASS
	SHELL___
		from string import Template
		n1 = 'hi'
		n2 = 'yo'
		n5 = 'Gotcha'
		n6 = 'bitch'

		n = Template('$n3 ! This is $n4')
		print(n.substitute(n3=n1, n4=n2))
		print(n.substitute(n3=n5, n4=n6))
		
	TERMINAL
		hi ! This is yo
		Gotcha ! This is bitch
		
STRING FORMATTING: % VS .FORMAT VS. F STRING LITERAL
f-strings are faster and better than both %-formatting and str.format(). f-strings expressions are evaluated at runtime, and we can also embed expression inside f-string using a very simple and easy syntax. The espressions inside the braces are evaluated in runtime and then put together with the string part of the f-string sand then the final string is returned. Use f strings if you on Python 3.6+ and .format() if you are not. 

[] PRACTICE F STRINGS
	SHELL___
		n1 = 'hi'
		n2 = 'yo'
		n5 = 'Gotcha'
		n6 = 'bitch'

		print(f"does this work {n1}  {n2}  {n5}  {n6}")
		
	TERMINAL
		does this work hi  yo  Gotcha  bitch
		
PYTHON STRING METHODS_______________________________________________________________________________________________________________________________________________________
Python string is a sequence of Unicode character that is enclosed in the quotation marks. In this article, we will discuss the in-built function i.e. the function provided by the Python to operate on strings. Every string method does not change the original strings instead returns a new string with the changed attributes.

CASE CHANGING OF STRINGS 
The below functions are used to change the case of the strings.' lower() ' - Converts all uppercase character in a string to lowercase.' upper() ' - Converts all lowercase characters in a string to uppercase.' title() ' Covert string to title case.' swapcase() ' swap the cases of all characters in a string. 

[] CHANGING CASE
	SHELL____
		AString='Yo, HELLP. Emotional DamaGE'
		print(AString)
		print(AString.upper())
		print(AString.lower())
		print(AString.title())
		print(AString.swapcase())
		
	TERMINAL
		Yo, HELLP. Emotional DamaGE
		YO, HELLP. EMOTIONAL DAMAGE
		yo, hellp. emotional damage
		Yo, Hellp. Emotional Damage
		yO, hellp. eMOTIONAL dAMAge

[ THAT IS LITERALLY THE END OF THAT CHAPTER LOL ]

PYTHON Math OPERATORS___________________________________________________________________________________________________________________________________________________
Math Operators are used to perform mathematical operations like addition, subtraction, multiplication and division. There are 7 Math operators in Python: 1. Addition, 2. Subtraction, 3. Multiplication, 4. Division, 5. Modulus, 6. Exponentiation, 7. Floor Division. In Python, * is the multiplication operator. It is used to find the product of 2 values. In Python,/ is the division operator. It is used to find the quotient when first operand is divided by the second. In Python, % is the modulus operator. It is used to find the remainder when first operand is divided by the second. In Python, ** is the exponentiation operator. It is used to raise the first operand to power of second. In Python, // is used to conduct the floor division. It is used to find the floor of the quotient when first operand is divided by the second.

ADDITION OPERATOR
In Python, + is the addition operators. It is used to add 2 values. 

[] ADDITION OPERATOR
	SHELL___
		print('are you' + ' fucking serious')
		
	TERMINAL
		are you fucking serious
		
[] SUBTRACTION OPERATOR
	SHELL___
		print(3-2)
		
	TERMINAL
		1
		
[] MULTIPLACATION OPERATOR
	SHELL___
		print(3*2)
		
	TERMINAL
		6
		
[] DIVISION OPERATOR
	SHELL___
		print(3/2)
		
	TERMINAL
		1.5
		
[] MODULUS OPERATOR
	SHELL___
		print(3%2)
		
	TERMINAL
		1

[] EXPONENTIATION OPERATOR
    SHELL___
        print(3**2)
        
    TERMINAL
        9
		
[] FLOOR DIVISION
    SHELL___
        print(3//2)
        
    TERMINAL
        1
        
MATH MODULE______________________________________________________________________________________________________________________________________________________________________
Sometimes when working with some kind of financial or scientific projects it become necessary to implement mathematical colculations in the project. Python provides the MATH MODULE to deal with such calculations. MATH MODULE provide functions to deal with both basic operations such as addition(+), subtraction(-), multiplication(*), division(/) and advanced operations like trigonometric, logarithmic, exponential functions. In this article, we learn about the MATH MODULE from basics to advance using the help of a huge dataset containing functions explained with the help of good examples

' trigonometry ' - The branch of mathematics dealing with the relations of the sides and angles of triangles and with the relevant functions of an angles. 

' logrithmic ' - Constructed so that successive points along an axis, or graduations which are an equal distance apart, represent values which are in an equal ratio. 

CONSTANTS PROVIDED BY THE MATH MODULE
MATH MODULE provides the value of various CONSTANTS like pi, tau. Having such constants saves the time of writing the value of each constant every time we went to use it and that too with great precision. Constants provided by the math module are - Euler's Number, Pi, Tau, Infinity, Not a Number(NaN). Lets see each in detail. PI - You all must be familiar with pi. The pi is depicted as wither 22/7 or 3.14.' math.pi ' provides a more precise value for the pi. EULER'S NUMBER - The math.e constant returns the Euler's number: 2.71828182846. CIRCLE AREA - This equals ' pi * radius sqaured. TAU - is defined at the ratio of the circumference to the radius of a circle. The math.tau constant returns the value tau: 6.283185307179586. 

EULERS NUMBER
	SHELL___
		import math
		Eulers = (math.e)
		print (type(Eulers))
		print(" I don't know a better way of porting %.03f into this string, using the old school way" % (Eulers))
		
	TERMINAL
		<class 'float'>
		I don't know a better way of porting 2.718 into this string, using the old school way

PI
	SHELL___
		import math
		print(math.pi)
		print('%.02f' % (math.pi))
		
	TERMINAL
		3.141592653589793
		3.14
		
CIRCLE AREA
	SHELL___
		import math
		RadiusSquared=(4*4)
		print((math.pi)*(RadiusSquared))
		
	TERMINAL
		50.26548245743669

MATHEMATICAL FUNCTIONS IN PYTHON: SET ONE
In Python a number of mathematical operations can be performed with easy by importing a module named "math" which defines various functions which makes our tasks easier. 1. ) ' ceil() ' - This function returns the smallest integral alue greated than the number. If number is already integer, same number is returned. 2. )' floor() ' - This function returns the greatest integral value smaller than the number. If number is already integer, same number is returned. 3. )' fabs() ' - This function returns the absolute value of the number. 4.)' factorial() ' - This function returns the factorial of the number. An error message is displayed if the number is not integral. 5. )' copysign(a,b) ' - This function returns the number with the value of ' a ' but with the sign of ' b '. The returned number is a float. 6. )' gcd() - This function is used to compute the greatest common divisor of 2 numbers mentioned in it arguments. The function works in Python 3.5 and above. 

' absolute value '- the magnitude of a real number without regard to its sign

' factorial '- the product of an integer and all integers below it, factorial of 5 is 120 (5x4x3x2x1)

CEILING
	SHELL___
		import math
		a=2.3
		print(math.ceil(a))
		print(math.floor(a))
		
	TERMINAL
		3
		2
		
FLOOR
	SHELL___
		import math
		a=2.3
		print(math.ceil(a))
		print(math.floor(a))
		
	TERMINAL
		3
		2
		
FABS
	SHELL___
		import math
		A = -10
		print(math.fabs(A))
		
	TERMINAL
		10.0
		
FACTORIAL
	SHELL___
		import math

		anumber=5
		print(math.factorial(anumber))
		
	TERMINAL
		120
		
COPYSIGN
	SHELL___
		import math
		a = -10
		print(math.copysign(7.2,a))
		
	TERMINAL
		-7.2
		
GREATEST COMMON DIVISOR (LOWEST COMMON DENOMINATOR)
	SHELL___
		import math
		a = -10
		print(math.gcd(12,a))
		print(math.gcd(15,a))
		print(math.gcd(78,a))
		print(math.gcd(92,a))
		print(math.gcd(305,a))
		
	TERMINAL
		2
		5
		2
		2
		5

PYTHON IF ELSE (CONTROL FLOW)___________________________________________________________________________
There comes situations in real life when we need to make some decisions and based on these decisions, we decide what should we do next. Similar situations arise in programming also where we need to make some decisions and based on these decisions we will execute the next block of code. Decision-making satements in programming languages decide the direction (Control Flow) of the flow of program execution. Within there is some complexity to the way that a boolean can operate. I'm finding that that part is more tricky as you to deal with the true/false values of strings, and other elements that don't really fit in the same units. 

TYPES OF CONTROL FLOW IN PYTHON
In Python, the type of control flow statements are as follows: 1.) ' the if statement ' , 2. ) ' the if-else statement ', 3. ) ' the nested statement ', 4. ) ' the if-elif-else ladder '. 

IF STATEMENT 
The if statement is the most simple decision-making statement. It is used to decide wheter a certain statement or block of statements will be executed. Here, the condition after evaluation will be either true or false. If the statement accepts boolean values - if the values is true then it will execute the block of statements below it otherwise not. As we know, python uses indentation to identify a block. So the block under an if statement will be identified as shown in the below example: As the condition present in the if statement is false. So, the block below the if statement is executed. 

' boolean ' - denoting a system of algebraic notation used to represent logical propositions, especially in computing and electronics. A binary variable having two possible values called true and false. Boolean's format specifier is a %s

' block ' - A piece of Python program text that is executed as a unit. The following are blocks: a module, a funtion, and a class definition. Each command typed interactively is a block. 

IF STATEMENT FLOWCHART


		Test Expression --------- FALSE
				|					|
				|					|
			  TRUE					|
				|					|
				|					|
		   body of if				|
				|					|
				|___________________|
				|
				|
	  statement just below if
				|
				|
			   \ /
			   
IF STATEMENT
	SHELL___
		a=10
		print(a)
		if (a > 15):
		print("10 is less than 15")
		if(a<15):
			print('a is 10 and 10 is less than 15')
			print('\tthere is a line above this saying print("10 is less than 15")\n\tit doesnt fire because it needed to meet the boolean (a>15) \n\ta is less than 15')

		b=20
		print(b)
		if(b > 15):
			print("20 is larger than 15")
		print('\tthis line printed and the one above it also printed because the boolean was met \n\t20 is larger than 15 and it printer a line that says so')
	
	TERMINAL
		10
		a is 10 and 10 is less than 15
			there is a line above this saying print("10 is less than 15")
			it doesnt fire because it needed to meet the boolean (a>15) 
			a is less than 15
		20
		20 is larger than 15
			this line printed and the one above it also printed because the boolean was met 
			20 is larger than 15 and it printer a line that says so
			
IF ELSE STATEMENT
	The is statement alone tells us that if a condition is true it will execute a block of statements and if the condition is false it won't. But if we want to do something else if the conidition is false, we can use the else statment with if statement to execute a block of code when the if condition is false, we can use the else statment with if statment ot execute a block of code when the if condition is false. The block of code following the else statment is executed as the condition present in the if statement is false after calling teh statment which is not in the block (without spaces)
	
IF ELSE FLOWCHART


		Test Expression___________________________FALSE
			  |										|
			  |										|
			 TRUE									|
			  |										|
			  |										|
	     Body of if								Body of else 
			  |										|
			  |										|
			  |_____________________________________|
			  |
			  |
	Statement just below if
			  |
			  |
			 \ /
			 
IF ELSE STATEMENT
	SHELL___
		mag=25
		mag2=15
		if (mag > 20):
			print("20+ rounds available in mag")
		else:
			print("less than 20 rounds available in mag")
		if (mag2 > 20):
			print("20+ rounds available in mag2")
		else:
			print("less than 20 rounds available in mag2")
			
	TERMINAL
		20+ rounds available in mag
		less than 20 rounds available in mag2
		
IF ELSE IN LIST COMPREHENSION

' def ' - The def keyword is used to create, or define a function. 

- No clue what is happening on this one

	SHELL___
		def digitSum(n):
			dsum = 0
			for ele in str(n):
				dsum += int(ele)
			return dsum
    
		List = [868,474,282,373,2828,393]
		newList=[digitSum(i) for i in List if i & 1]
		print(newList)
		
	TERMINAL
		[13,15]
		
NESTED IF STATEMENT
A nested is is an if statement that is the target of another if statement. Nested if statements mean an if statement inside another if statment. Yes, Python allows us to nest if statments within if statements. i.e, we can place an if statement inside another if statement. 

 NESTED IF FLOWCHART
 
 
		test expression____________TRUE____________nested test______
			   |									expression     |
			   |										|		   |
			 FALSE									  TRUE		 FALSE
			   |										|		   |
			   |										|		   |
		  body of else						    	body of     body of
			   |								   nested if   nested else
			   |________________________________________|          |
			   |___________________________________________________|
			   |
		statement just
		   below if
			   |
			   |
			  \ /
			   X
			   
NESTED IF STATMEMENT
	SHELL____
		#10 is too small to pass
		i = 10
		if (i == 10):
			if (i < 15):
				print("1.) i is 10 and 10 is smaller than 15")
			if(i < 12):
				print("2.) i is 10 and 10 is smaller than 12 too")
			else:
				print("i is greater than 15")
		print("3.) ")
		print("4.) ")
		
		#20 is too large to pass
		a = 20
		if (a == 20):
			if (a < 15):
				print("a is 20 and 20 is larger than 15")
			if(a < 12):
				print("a is 20 and 20 is larger than 12 too")
			if(a < 25):
				print('there are two missing if conditions above stating: \n\n\t\ta<15?: a is 20 and 20 is larger than 15 \n\t\ta<12?: 20 is larger than 12 too')
		if(a<30):
			print("\n5.) a is 20 and 20 is greater than 15")
			
	TERMINAL
		1.) i is 10 and 10 is smaller than 15
		2.) i is 10 and 10 is smaller than 12 too
		3.) 
		4.) 
		there are two missing if conditions above stating: 

			a<15?: a is 20 and 20 is larger than 15 
			a<12?: 20 is larger than 12 too

		5.) a is 20 and 20 is greater than 15
		
IF ELIF ELSE 
Here, a user can decide among multiple options. The if statements are executed from the top down. As soon as one of the conditions controlling the if is true, the statment associated with that if is executed, and the rest of the ladder is bypassed. If non of the conditions is true, then the final else statement will be executed. 

IF ELIF ELSE FLOWCHART


		test expression 1____________Yes____________statement 1___
			  |                                                   |
			  No												  |
			  |													  |
		test espression 2____________Yes____________statement 2___|
			  |													  |
			  No												  |
			  |													  |
		test espression 3____________Yes____________statement 3___|
			  |													  |
			  |_____________________________________body of else__|
																  |
																  |
														Statement just below
														      if-elseif
															  
IF ELIF ELSE
	SHELL____
		i = 20
		if (i == 10):
			print("i is 10")
		elif (i == 15):
			print("i is 15")
		elif (i == 20):
			print("i is 20")
		else:
			print("i is not present")
			
	TERMINAL
		i is 20
		
IF ELIF ELSE LADDER
	SHELL___
		a = 10
		b = 15
		c = 20
		d = 5
		print('a is: %d\nb is: %d\nc is: %d\nd is: %d' % (a,b,c,d))
		if (a == 10):
			print("\na is 10, and the if statement is satified, if won't try (a==15) and (a==20) below it because this first if statement is true")
		elif (a == 15):
			print("i is 15")
		elif (a == 20):
			print("i is 20")
		else:
			print("d is not present")

		if (b == 9):
			print("i is 10")
		elif (b == 15):
			print("b is 15 and it failed (b==9) but passed this one,(b==15) because b is 15. It won't try (b==20) below it")
		elif (b == 20):
			print("i is 20")
		else:
			print("d is not present")
    
		if (c == 9):
			print("c is 10")
		elif (c == 14):
			print("c is 15")
		elif (c == 20):
			print('c is 20 and it failed (c==9) and (c==14) before (c==20) because c is 20')
		else:
			print("d is not present")
    
		if (d == 9):
			print("c is 10")
		elif (d == 14):
			print("c is 15")
		elif (d == 20):
			print('c is 20 and it failed (c==9) and (c==14) before (c==20) because c is 20')
		else:
		print("\nd is not present because it fails all three: (d==9),(d==14),(d==20)")
		
	TERMINAL
		a is: 10
		b is: 15
		c is: 20
		d is: 5

		a is 10, and the if statement is satified, if won't try (a==15) and (a==20) below it because this first if statement is true
		b is 15 and it failed (b==9) but passed this one,(b==15) because b is 15. It won't try (b==20) below it
		c is 20 and it failed (c==9) and (c==14) before (c==20) because c is 20

		d is not present because it fails all three: (d==9),(d==14),(d==20)
		
SHORTHAND STATEMENT
Whenever there is only a single statement to be executed inside the if block then shorthand if can be used. The statement can be put on rhe same line as the if statement.

SHORTHAND IF ELSE
This can be used to write the if-else statements in a sinle line where only one statment is needed in both if and else block. 

SHORTHAND STATEMENTS
	SHELL___
		#Shorthand is statement
		a = 10
		if a < 15: print("SHORTHAND IF STATEMENT TRUE: a is less than 15")

		#Shorthand if else statement
		print("\nPrint ' True ' if a is less than 15 and print ' False ' if there is anything else")
		print(True) if a < 15 else print(False)
		
	TERMINAL
		SHORTHAND IF STATEMENT TRUE: a is less than 15

		Print ' True ' if a is less than 15 and print ' False ' if there is anything else
		True
		
PYTHON OPERATORS
Operators in general are used to perform operations on values and variables. These are standard symbols used for the purpose of logical and Math operations. In this article, we will
look into different types of Python operators.

' OPERATORS ' - These are the special symbols ( - + * / )
' OPERAND ' - Is the value on which the operator is applied

WORD WRAP IN PYCHARM
#  ctrl-shift-a > "soft" > select 'Active Editor: Use Soft Wraps'
#
# COMMENT AND UNCOMMENT LINES OF CODE
# Highlight code > ctrl + /
#
# TYPES OF OPERATORS IN PYTHON
# 1. ) Math Operators. 2. ) Comparison Operators 3. ) Logical Operators 4. ) Bitwise Operators 5. ) Assignment Operators 6. ) Identity Operators and Membership Operators.
#
# Math OPERATORS
# # Python Math Operators are used to perform basic mathematical opertations liek addition, subtraction, multiplication, and division. In Python 3.x the result of division is a floating-point while in Python 2.x division of 2 integers was an integer. To obtain an integer result in Python 3.x floored(//integer)is used.
#
# ' + ' - Addition, adds two operands ( x + y )
# ' - ' - Subtractions, subtracts two operands ( x - y )
# ' * ' - Multiplication, multiplies two operands ( x * y )
# ' / ' - Division (float), divides the first operand by the second ( x / y )
# ' // ' - Division (floor), divides the first operand by the second ( x // y )
# ' % ' - Modulus, returns the remainder when the first operand is divided by the second ( x % y )
' ** ' - Power, returns first raised to power second ( x ** y )

EXAMPLES OF ARTIHMETIC OPERATORS IN PYTHON
DIVISION OPERATORS
Allow you to divide two numbers and return a quotient, the first number or number at the left is divided by the second umber at the right and returns the quotient. There are two types of division operators 1. ) Float Division, 2. ) Floor Division

FLOAT DIVISION
The quotient returned by this operator is always a float number, no matter if two numbers are integers. For example:

    SHELL___
        print(5/5)
        print(10/2)
        print(-10/2)
        print(20.0/2)

    TERMINAL
        1.0
        5.0
        -5.0
        10.0

INTEGER DIVISION
The quotient return by this operator is dependent on the argument being passed. If any of the number is float, it returns output in float. It is also know as a Floor Division because, if any number is negative, then the output will be floor for example:

' floored ' - Round a number down to the nearest integer, if necessary, and returns the result.

    SHELL___
        print(10//3)
        print(-5//2)
        print(5.0//2)
        print(-5.0//2)

    TERMINAL
        3
        -3
        2.0
        -3.0

PRECEDENCE OF Math OPERATORS IN PYTHON
The precedence of Math operators in python is as follows: 1. ) P - Parentheses, 2. ) E - Exponents
3. ) M - Multiplication, 4. ) - Division. 5. ) - Addition, 6. ) S - Subtraction. The modulus operator helps us extract the last digits of a number. For example:

' x%10 ' - yields the last digit
' x%100 ' - yields the last two digits

Math OPERATORS WITH ADDITION, SUBTRACTION, MULTIPLICATION, MODULO AND POWER
Here is an example showing how different Math Operators in Python work:
    SHELL___
        a = 9
        b = 4
        add = a+b
        sub = a-b
        mul = a*b
        mod = a%b
        p = a**b
        print(add)
        print(sub)
        print(mul)
        print(mod)
        print(p)

    TERMINAL
        13
        5
        36
        1
        6561

COMPARISON OPERATORS IN PYTHON
Comparison of Relational operators compares the values. It either returns True or False according to the condition.

' > ' | GREATER THAN: True if the left operand is greater than the right operand | x > y
' < ' | LESS THAN: True is the left operand is less than the right | x < y
' == ' | EQUAL TO: True if both operand are equal, this is a comparision operator | x == y
' != ' | NOT EQUAL TO: True if both operand are not equal | x != y
' >= ' | GREATER THAN OR EQUAL TO: True if the left operand is greater than or equal to the right | x >= y
' <= ' | LESS THAN OR EQUAL TO: True if the left operand is less than or equal to the right | x <= y

' = ' - This sets one object equal to another so that it can be 'renamed' essentially. Is an assignment operator, which is used to assign values to variables. Assign the value of the right side of the expression to the left side operand

PRECEDENCE OF COMPARISON OPERATORS IN PYTHON
The comparison operators have a lower precedence than the Math operators. All the operators within comparison operators have the same precedence order.

' precedence ' - To evaluate these types of expressions there is a rule of precedence in Python. It guides the order in which these operations are carried out. For Example, multiplication has
--------------   higher precedence than subtraction.

    SHELL___
        a=13
        b=33

        print(a > b)
        print(a < b)
        print( a == b)
        print(a != b)
        print(a >= b)
        print( a <= b)

    TERMINAL
        False
        True
        False
        True
        False
        True

_ I'm going to combine this with if elif else loop to see how those can work together:

    SHELL___
        checking=1700
        credit1=700
        credit2=300
        credit3=700
        creditall=(credit1+credit2+credit3)
        print (f'CHECKING: {checking}')
        print(f'CREDIT: {creditall}')

        if(checking<creditall): print('use credit')
        elif(checking>creditall): print('get more credit')
        else: print ('I got 99 problems but financial aint one!!!')

        checking=17
        credit1=700
        credit2=300
        credit3=700
        creditall=(credit1+credit2+credit3)
        print (f'\nCHECKING: {checking}')
        print(f'CREDIT: {creditall}')

        if(checking<creditall): print('use credit')
        elif(checking>creditall): print('get more credit')
        else: print ('I got 99 problems but financial aint one!!!')

        checking=5000
        credit1=700
        credit2=300
        credit3=700
        creditall=(credit1+credit2+credit3)
        print (f'\nCHECKING: {checking}')
        print(f'CREDIT: {creditall}')

        if(checking<creditall): print('use credit')
        elif(checking>creditall): print('get more credit')
        else: print ('I got 99 problems but financial aint one!!!')

    TERMINAL
        C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
        CHECKING: 1700
        CREDIT: 1700
        I got 99 problems but financial ain't one!!!

        CHECKING: 17
        CREDIT: 1700
        use credit

        CHECKING: 5000
        CREDIT: 1700
        get more credit

        Process finished with exit code 0

LOGICAL OPERATORS IN PYTHON
Perform logical operators perform logical ' AND ', ' OR ', ' NOT ' operations. It is used to combine conditional statements. These return True or False

' and ' | LOGICAL AND: True if both the operands are true | x and y
' or ' | LOGICAL OR: True if either of the operands are true | x or y
' not ' | LOGICAL NOT: True if the operand is false | not x

PRECEDENCE OF LOGICAL OPERATORS
The precedence of logical operators is as follows: 1. ) ' NOT ', 2. ) ' AND ', 3. ) OR.


- Me experimenting with logical operators on top of comparison operators.
SHELL___
a=75
b=56
c=37
d=128
e=12

if (a<b) and (c<d):
    print('50 is greater than 50 and 10 is less than 20')
elif(a<(b+c)) or ((b+c)>(a-b)):
    print('hahaha, I have no idea what the fuck is going on')
else:
    print('bitch please')

a=12
b=13
c=14
d=15
e=16

if (a<b) and (c<d):
    print('\n50 is greater than 50 and 10 is less than 20')
elif(a<(b+c)) or ((b+c)>(a-b)):
    print('\nhahaha, I have no idea what the fuck is going on')
else:
    print('\nbitch please')

a=0
b=0
c=0
d=0
e=0

if (a<b) and (c<d):
    print('\n50 is greater than 50 and 10 is less than 20')
elif(a<(b+c)) or ((b+c)>(a-b)):
    print('\nhahaha, I have no idea what the fuck is going on')
else:
    print('\nbitch please')

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
hahaha, I have no idea what the fuck is going on

50 is greater than 50 and 10 is less than 20

bitch please

Process finished with exit code 0

- It seems important to mention the kinds of operators so you remember the categories you have to organize your data and make different data types relate to other data types so far you have
Math - Which can do Math on the same types perhaps? or only integers? Lets test. First we have to list all the data types that we can have:

' types ' - Strings %s, Integers %i, Floats %f, Any number %d, Complex (x)j ( you have to add this to something to get a 'complex' type like ((<%d>)j <Math operator> %d). Printing
---------   something like this will give you a complex type number.

___SHELL___
GotA= True
NoGotA = False

print(GotA and NoGotA)
print(GotA or NoGotA)
print(not GotA)

___TERMINAL___
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
False
True
False

Process finished with exit code 0

*BITWISE OPERATORS IN PYTHON
Acts on bits and performs bit-by-bit operations. There are used to operate on binary numbers
' & ' | BITWISE AND | x & y
' | ' \ BITWISE OR \ x | y
' ~ ' | BITWISE NOT | ~x
' ^ ' | BITWISE XOR | x ^ y
' >> ' | BITWISE RIGHT SHIFT | x>>
' << ' | BITWISE LEFT SHIFT | x<<

PRECEDENCE OF BITWISE OPERATORS IN PYTHON
The precedence of Bitwise operators in python is as follows. 1. ) BITWISE NOT, 2. ) BITWISE SHIFT, 3. ) BITWISE AND, 4. ) BITWISE XOR, 5. ) BITWISE OR

BITWISE OPERATORS IN PYTHON
Here is an example showing how Bitwise Operators work in Python:

- Need to go a bit more indepth about BITWISE operators

---SHELL---
a = 10
b = 4

print(a & b)
print(a | b)
print(~a)
print(a ^ b)
print(a >> 2)
print(a << 2)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
0
14
-11
14
2
40

Process finished with exit code 0

ASSIGNMENT OPERATORS IN PYTHON
These are used to assign values to the variables

= | ASSIGN: the values of the right side of the expression to the left side operand | x = y + z
+= |ADD AND: Add right-side operand with left-side operand and then assign to left operand | a+=b a=a+b
-= | SUBTRACT AND: Subtract right operand from left operands and the assign to left operand | a-=b a=a-b
*= | MULTIPLY AND: Multiply right operand with left operand and then assign to left operand | a*=b a+a*b
/= | DIVIDE AND: Divide left operand and then assign to left operand | a/=b a=a/b
%= | MODULUS: Take modulus using left and right operands and assign the result to left operand | a%=b a=a%b
//= | DIVIDE FLOOR: Divide left operand with right operand and then assign to left operand | a//=b, a=a//b
**= | EXPONENT AND: Calculate exponent (raise power) value using operands and assign value to left operand
&= | BITWISE AND: on operands and assign value to the left operand | a&=b a=a&b
|= | BITWISE OR: on operands and assign value to left operand | a|=b a=a|b
^= | BITWISE XOR: on operands and assign value to left operand |
>>= | BITWISE RIGHT SHIFT: on operands and assign value to left operand | a>>=b a=a>>b
<<= | BITWISE LEFT SHIFT: on operands and assign the value to the left operand

---SHELL---
a=10
b=20

a=(a+b)
print(a)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
30

Process finished with exit code 0

---SHELL---
a = 10

b = a
print(b)

b += a
print(b)

b -= a
print(b)

b *= a
print(b)

b <<= a
print(b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
10
20
10
100
102400

Process finished with exit code 0

IDENTITY OPERATORS IN PYTHON
Is and is not are the identity operators both are used to check if two values are located on the same part of the memory. Two variables that are equal do not imply that they are identical
' is ' - True if the operands are identical
' is not ' - True if the operand are not identical

---SHELL---
a=10
b=20
c=a

print(a is not b)
print(a is c)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
True
True

Process finished with exit code 0

MEMBERSHIP OPERATORS IN PYTHON
IN and not in are the membership operators that are used to test whether a value or variable is in a sequence

' in ' - True if value is found in the sequence
' not in ' - True if value is not found in the sequence

---SHELL---
x = 24
y = 20
list = [10,20,30,40,50]

if (x not in list):
    print('x is NOT present in given list')
else:
    print('x is present in given list')

if(y in list):
    print('y is present in given list')
else:
    print('y is not present in given list')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
x is NOT present in given list
y is present in given list

Process finished with exit code 0

TERNARY OPERATOR IN PYTHON
Ternary operators also know as conditional expressions are operators that evaluate something based on a condition being True or False. It simply allows testing a condition in a single line replacing the multiline if-else making the code compact.

---SHELL---
a, b = 'yes', 'doubleyes'

min = a if a < b else b
print(min)

a, b = 'yes', 'doubleyes'

min = a if a < b else b
print(min)

a, b = 'des', 'youbleyes'

min = a if a < b else b
print(min)

a, b = 'des', 'youbleyes'

min = a if a < b else b
print(min)

a, b = 'zes', 'zoubleyes'

min = a if a < b else b
print(min)

a, b = 'yes', 'zoubleyes'

min = a if a < b else b
print(min)

a, b = 'des', 'zoubleyes'

min = a if a < b else b
print(min)

a, b = 'zes', 'youbleyes'

min = a if a < b else b
print(min)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
doubleyes
doubleyes
des
des
zes
yes
des
youbleyes

Process finished with exit code 0

PRECEDENCE AND ASSOCIATIVITY
Operator precedence and associativity determine the priorities of the operator. Operator precedence is used in an expression with more than one operator with different precedence to determine. If an expression contains two or more operators with the same precedence then Operator Associativity is used to determine. If can either be left to right or right to left. The following code shows how Operator Associativity in Python works:

---SHELL---
print(100 / 10 * 10)
print(5 - 2 / 3)
print(5 - (2 + 3))
print(2 ** 3 ** 2)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0307_745.py
100.0
4.333333333333333
0
512

Process finished with exit code 0

ALL OPERATORS - 4071 Starts
1. ) Math Operators - 4074 [X]
2. ) Comparison Operators - 4151 [X]
3. ) Logical Operators - 4243 [X]
4. ) Bitwise Operators - 4327
5. ) Assignment Operators - 4366
6. ) Identity Operators and Membership Operators - 4424

' logical not ' -
Python's not operator allows you to invert the truth value of Boolean expressions and objects. You can use this operator in Boolean contexts, such as if statements and while loops. It also works in non-boolean contexts, which allows you to invert the truth value of your variables. Using the not operator effectively will help you write accurate negative Boolean expressions to control the flow of execution in your programs. In this tutorial you'll learn: How python's not operator works, How to use the not operator in Boolean and non-Boolean contexts, how to use the operator.net_() function to perform logical negation, How and when to avoid unnecessary negative logic in your code. You'll also code a few practical examples that will allow you to better understand some of the primary use cases of the not operator and the best practices around its use. o get the most out of this tutorial, you should have some previous knowledge about Boolean logic, conditional statements and while loops

ALL OPERATORS
-------------
---SHELL---
# ' + ' - Addition, adds two operands ( x + y )
# ' - ' - Subtractions, subtracts two operands ( x - y )
# ' * ' - Multiplication, multiplies two operands ( x * y )
# ' / ' - Division (float), divides the first operand by the second ( x / y )
# ' // ' - Division (floor), divides the first operand by the second ( x // y )
# ' % ' - Modulus, returns the remainder when the first operand is divided by the second ( x % y )
# ' ** ' - Power, returns first raised to power second ( x ** y )
numberone=1
numbertwo=2
stringone='stringone'
stringtwo='stringtwo'
floatone=1.123456789
floattwo=2.123456789
print('\n| OPERATORS |')
print('\nMATH OPERATORS:')
print('ADDITION:')
print('1 + 2 = %d' % (numberone+numbertwo))
print('stringone + stringtwo = %s' % (stringone+stringtwo))
print ('1.123456789 + 2.123456789 = %f' % (floatone+floattwo))

print('\nSUBTRACTION:')
print('2 - 1 = %d' % (numbertwo-numberone))
print('(you cant subtract strings)')
print('2.123456789 - 1.123456789 = %f' % (floattwo-floatone))

print('\nMULTIPLICATION:')
print('1 * 2 = %d' % (numberone*numbertwo))
print('(you cant multiply strings)')
print('1.123456789 * 2.123456789 = %f' % (floatone*floattwo))

print('\nDIVISION:')
print('\tfloat format specifier (f): 1 / 2 = %f' % (numberone/numbertwo))
print('\tinteger format specifier (d): 1 / 2 = %d' % (numberone/numbertwo))
print('(you cant divide strings)')
print('2.123456789 / 1.123456789 = %f' % (floattwo/floatone))

print('\nFLOOR DIVISION (rounded down to nearest integer:')
print('\tfloat format specifier (f): 1 // 2 = %f' % (numberone//numbertwo))
print('\tdecimal format specifier (d): 1 // 2 = %d' % (numberone//numbertwo))
print('(you cant floor divide strings)')
print('1.123456789 // 2.123456789 = %f' % (floatone//floattwo))

print('\nMODULUS (remainder after division):')
print('24 <percentsign> 7 = %d' % (24%7))
print('you cant pull modulus for strings')
print('2.123456789 <percentsign> 1.123456789 = %f' % (2.123456789%1.123456789))

print('\nPOWERS:')
print(' 40 ** 2 = %d' % (40**numbertwo))
print('\tproof: 40 * 40 = %d' % (40*40))
print('you cant multiply powers of a string')
print('\tfloat format specifier: 2.123456789 ** 1.123456789 = %f' % (floattwo**floatone))
print('\tdecimal format specifier: 2.123456789 ** 1.123456789 = %d' % (floattwo**floatone))

#' > ' | GREATER THAN: True if the left operand is greater than the right operand | x > y
#' < ' | LESS THAN: True is the left operand is less than the right | x < y
#' == ' | EQUAL TO: True if both operand are equal, this is a comparision operator | x == y
#' != ' | NOT EQUAL TO: True if both operand are not equal | x != y
#' >= ' | GREATER THAN OR EQUAL TO: True if the left operand is greater than or equal to the right | x >= y
#' <= ' | LESS THAN OR EQUAL TO: True if the left operand is less than or equal to the right | x <= y

print('\nCOMPARISON OPERATORS')
print('GREATER THAN:')
print('\t1 > 2 = %s' % (1>2))
print('\t2 > 1 = %s' % (2>1))
print('\t1 > 1 = %s' % (1>1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone > stringtwo = %s' % (stringone>stringtwo))
print('\tstringtwo > stringone = %s' % (stringtwo>stringone))
print('\tstringone > stringone = %s' % (stringone>stringone))
print('\t\to > t = %s' % ('o'>'t'))
print('\t\tt > o = %s' % ('t'>'o'))
print('\t\to > o = %s' % ('o'>'o'))

print('\nLESS THAN:')
print('\t1 < 2 = %s' % (1<2))
print('\t2 < 1 = %s' % (2<1))
print('\t1 < 1 = %s' % (1<1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone < stringtwo = %s' % (stringone<stringtwo))
print('\tstringtwo < stringone = %s' % (stringtwo<stringone))
print('\tstringone < stringone = %s' % (stringone<stringone))
print('\t\to < t = %s' % ('o'<'t'))
print('\t\tt < o = %s' % ('t'<'o'))
print('\t\to < o = %s' % ('o'<'o'))

print('\nEQUALS TO (Comparison):')
print('\t1 == 2 = %s' % (1==2))
print('\t2 == 1 = %s' % (2==1))
print('\t1 == 1 = %s' % (1==1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone == stringtwo = %s' % (stringone==stringtwo))
print('\tstringtwo == stringone = %s' % (stringtwo==stringone))
print('\tstringone == stringone = %s' % (stringone==stringone))
print('\t\to < t == %s' % ('o'=='t'))
print('\t\tt < o == %s' % ('t'=='o'))
print('\t\to < o == %s' % ('o'=='o'))

print('\n NOT EQUALS TO:')
print('\t1 != 2 = %s' % (1!=2))
print('\t2 != 1 = %s' % (2!=1))
print('\t1 != 1 = %s' % (1!=1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone != stringtwo = %s' % (stringone!=stringtwo))
print('\tstringtwo != stringone = %s' % (stringtwo!=stringone))
print('\tstringone != stringone = %s' % (stringone!=stringone))
print('\t\to != t != %s' % ('o'!='t'))
print('\t\tt < o != %s' % ('t'!='o'))
print('\t\to < o != %s' % ('o'!='o'))

print('\n GREATER THAN OR EQUAL TO:')
print('\t1 >= 2 = %s' % (1>=2))
print('\t2 >= 1 = %s' % (2>=1))
print('\t1 >= 1 = %s' % (1>=1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone >= stringtwo = %s' % (stringone!=stringtwo))
print('\tstringtwo >= stringone = %s' % (stringtwo!=stringone))
print('\tstringone >= stringone = %s' % (stringone!=stringone))
print('\t\to >= t = %s' % ('o'>='t'))
print('\t\tt >= o = %s' % ('t'>='o'))
print('\t\to >= o = %s' % ('o'>='o'))

print('\n LESS THAN OR EQUAL TO:')
print('\t1 <= 2 = %s' % (1<=2))
print('\t2 <= 1 = %s' % (2<=1))
print('\t1 <= 1 = %s' % (1<=1))
print('\n\tStrings are in alphabetical order:')
print('\tstringone <= stringtwo = %s' % (stringone<=stringtwo))
print('\tstringtwo <= stringone = %s' % (stringtwo<=stringone))
print('\tstringone <= stringone = %s' % (stringone<=stringone))
print('\t\to <= t = %s' % ('o'<='t'))
print('\t\tt <= o = %s' % ('t'<='o'))
print('\t\to <= o = %s' % ('o'<='o'))

#numberone=1
#numbertwo=2
#stringone='stringone'
#stringtwo='stringtwo'
#floatone=1.123456789
#floattwo=2.123456789
#' and ' | LOGICAL AND: True if both the operands are true | x and y
#' or ' | LOGICAL OR: True if either of the operands are true | x or y
#' not ' | LOGICAL NOT: True if the operand is false | not x

print('\nLOGICAL OPERATORS')
print('AND: will choose whatever is in the right operand')
print('\n\tintegers:')
print('<string> 1 and 2 = %s' % (1 and 2))
print('<integer> 1 and 2 = %i' % (1 and 2))
print('<decimal> 1 and 2 = %d' % (1 and 2))
print('<float> 1 and 2 = %f' % (1 and 2))
print('\n<string> 2 and 1 = %s' % (2 and 1))
print('<integer> 2 and 1 = %i' % (2 and 1))
print('<decimal> 2 and 1 = %d' % (2 and 1))
print('<float> 2 and 1 = %f' % (2 and 1))
print('\n\tstrings:')
print('stringone and stringtwo = %s' % (stringone and stringtwo))
print('stringtwo and stringone = %s' % (stringtwo and stringone))
print("\to and t = %s" % ('o' and 't'))
print("\tt and o = %s" % ('t' and 'o'))
print('\n\tfloats:')
print("1.123456789 and 2.123456789 = %.09f" % (floatone and floattwo))
print("2.123456789 and 1.123456789 = %.09f" % (floattwo and floatone))

print('\nOR: will choose whatever is in the left operand')
print('\tintegers:')
print('<string> 1 or 2 = %s' % (1 or 2))
print('<integer> 1 or 2 = %i' % (1 or 2))
print('<decimal> 1 or 2 = %d' % (1 or 2))
print('<float> 1 or 2 = %f' % (1 or 2))
print('\n<string> 2 or 1 = %s' % (2 or 1))
print('<integer> 2 or 1 = %i' % (2 or 1))
print('<decimal> 2 or 1 = %d' % (2 or 1))
print('<float> 2 or 1 = %f' % (2 or 1))
print('\n\tstrings:')
print('stringone or stringtwo = %s' % (stringone or stringtwo))
print('stringtwo or stringone = %s' % (stringtwo or stringone))
print("\to or t = %s" % ('o' and 't'))
print("\tt or o = %s" % ('t' and 'o'))
print('\n\tfloats:')
print("1.123456789 or 2.123456789 = %.09f" % (floatone or floattwo))
print("2.123456789 or 1.123456789 = %.09f" % (floattwo or floatone))

print('\nNOT: work on this after while loops')

#*BITWISE OPERATORS IN PYTHON
#Acts on bits and performs bit-by-bit operations. There are used to operate on binary numbers
#' & ' | BITWISE AND | x & y
#' | ' \ BITWISE OR \ x | y
#' ~ ' | BITWISE NOT | ~x
#' ^ ' | BITWISE XOR | x ^ y
#' >> ' | BITWISE RIGHT SHIFT | x>>
#' << ' | BITWISE LEFT SHIFT | x<<

print('1 & 1 = %d' % (1&1))
print('2 & 2 = %d' % (2&2))
print('7 & 10 = %d' % (2&2))

ASSIGNMENT OPERATORS IN PYTHON
These are used to assign values to the variables

#= | Assign the values of the right side of the expression to the left side operand | x = y + z
#+= | Add AND: Add right-side operand with left-side operand and then assign to left operand | a+=b a=a+b
#-= | SUBTRACT AND: Subtract right operand from left operands and the assign to left operand | a-=b a=a-b
#*= | MULTIPLY AND: Multiply right operand with left operand and then assign to left operand | a*=b a+a*b
#/= | DIVIDE AND: Divide left operand and then assign to left operand | a/=b a=a/b
#%= | MODULUS: Take modulus using left and right operands and assign the result to left operand | a%=b a=a%b
#//= | DIVIDE FLOOR: Divide left operand with right operand and then assign to left operand | a//=b, a=a//b
#**= | EXPONENT AND: Calculate exponent (raise power) value using operands and assign value to left operand
#&= | BITWISE AND: on operands and assign value to the left operand | a&=b a=a&b
#|= | BITWISE OR: on operands and assign value to left operand | a|=b a=a|b
#^= | BITWISE XOR: on operands and assign value to left operand |
#>>= | BITWISE RIGHT SHIFT: on operands and assign value to left operand | a>>=b a=a>>b
#<<= | BITWISE LEFT SHIFT: on operands and assign the value to the left operand

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py

| OPERATORS |

MATH OPERATORS:
ADDITION:
1 + 2 = 3
stringone + stringtwo = stringonestringtwo
1.123456789 + 2.123456789 = 3.246914

SUBTRACTION:
2 - 1 = 1
(you cant subtract strings)
2.123456789 - 1.123456789 = 1.000000

MULTIPLICATION:
1 * 2 = 2
(you cant multiply strings)
1.123456789 * 2.123456789 = 2.385612

DIVISION:
	float format specifier (f): 1 / 2 = 0.500000
	integer format specifier (d): 1 / 2 = 0
(you cant divide strings)
2.123456789 / 1.123456789 = 1.890110

FLOOR DIVISION (rounded down to nearest integer:
	float format specifier (f): 1 // 2 = 0.000000
	decimal format specifier (d): 1 // 2 = 0
(you cant floor divide strings)
1.123456789 // 2.123456789 = 0.000000

MODULUS (remainder after division):
24 <percentsign> 7 = 3
you cant pull modulus for strings
2.123456789 <percentsign> 1.123456789 = 1.000000

POWERS:
 40 ** 2 = 1600
	proof: 40 * 40 = 1600
you cant multiply powers of a string
	float format specifier: 2.123456789 ** 1.123456789 = 2.330339
	decimal format specifier: 2.123456789 ** 1.123456789 = 2

COMPARISON OPERATORS
GREATER THAN:
	1 > 2 = False
	2 > 1 = True
	1 > 1 = False

	Strings are in alphabetical order:
	stringone > stringtwo = False
	stringtwo > stringone = True
	stringone > stringone = False
		o > t = False
		t > o = True
		o > o = False

LESS THAN:
	1 < 2 = True
	2 < 1 = False
	1 < 1 = False

	Strings are in alphabetical order:
	stringone < stringtwo = True
	stringtwo < stringone = False
	stringone < stringone = False
		o < t = True
		t < o = False
		o < o = False

EQUALS TO (Comparison):
	1 == 2 = False
	2 == 1 = False
	1 == 1 = True

	Strings are in alphabetical order:
	stringone == stringtwo = False
	stringtwo == stringone = False
	stringone == stringone = True
		o < t == False
		t < o == False
		o < o == True

 NOT EQUALS TO:
	1 != 2 = True
	2 != 1 = True
	1 != 1 = False

	Strings are in alphabetical order:
	stringone != stringtwo = True
	stringtwo != stringone = True
	stringone != stringone = False
		o != t != True
		t < o != True
		o < o != False

 GREATER THAN OR EQUAL TO:
	1 >= 2 = False
	2 >= 1 = True
	1 >= 1 = True

	Strings are in alphabetical order:
	stringone >= stringtwo = True
	stringtwo >= stringone = True
	stringone >= stringone = False
		o >= t = False
		t >= o = True
		o >= o = True

 LESS THAN OR EQUAL TO:
	1 <= 2 = True
	2 <= 1 = False
	1 <= 1 = True

	Strings are in alphabetical order:
	stringone <= stringtwo = True
	stringtwo <= stringone = False
	stringone <= stringone = True
		o <= t = True
		t <= o = False
		o <= o = True

LOGICAL OPERATORS
AND: will choose whatever is in the right operand

	integers:
<string> 1 and 2 = 2
<integer> 1 and 2 = 2
<decimal> 1 and 2 = 2
<float> 1 and 2 = 2.000000

<string> 2 and 1 = 1
<integer> 2 and 1 = 1
<decimal> 2 and 1 = 1
<float> 2 and 1 = 1.000000

	strings:
stringone and stringtwo = stringtwo
stringtwo and stringone = stringone
	o and t = t
	t and o = o

	floats:
1.123456789 and 2.123456789 = 2.123456789
2.123456789 and 1.123456789 = 1.123456789

OR: will choose whatever is in the left operand
	integers:
<string> 1 or 2 = 1
<integer> 1 or 2 = 1
<decimal> 1 or 2 = 1
<float> 1 or 2 = 1.000000

<string> 2 or 1 = 2
<integer> 2 or 1 = 2
<decimal> 2 or 1 = 2
<float> 2 or 1 = 2.000000

	strings:
stringone or stringtwo = stringone
stringtwo or stringone = stringtwo
	o or t = t
	t or o = o

	floats:
1.123456789 or 2.123456789 = 1.123456789
2.123456789 or 1.123456789 = 2.123456789

NOT: work on this after while loops
BITWISE OPERATORS IN PYTHON
Acts on bits and performs bit-by-bit operations. There are used to operate on binary numbers
1 & 1 = 1
2 & 2 = 2
7 & 10 = 2
ASSIGNMENT OPERATORS IN PYTHON
These are used to assign values to the variables

Process finished with exit code 0

COMPARISON OPERATORS
You would have come across many operators like addition, subtractions, greater than, in Math. You would have come across it even in day-to-day life like comparing prices of two things. Some of such operators are Comparison Operators. We will learn about different operators that come under this category of operators in this article. So let us nto wait and begin.

INTRODUCTION TO COMPARISON OPERATORS
Comparison operators are the operators that compare the values on either side of the symbol. Depending on their operation, these checks if the two operands satisfy the given condition. Then return either True or False based on the result. Thus, these are also called relational operators

RELATIONAL OPERATORS IN PYTHON
Are used for comparing the values. It either returns True or False according to the condition. There operators are also known as Comparison Operators.

' > ' | GREATER THAN: True if the left operand is greater than the right operand | x > y
' < ' | LESS THAN: True if the left operand is less than the right | x < y
' == ' | EQUAL TO: True if both operands are equal | x == y
' != ' | NOT EQUAL TO: True if both operands are equal | x != y
' >= ' | GREATER THAN OR EQUAL TO: True if left operand is greater than or equal to the right | x >= y
' <= ' | LESS THAN OR EQUAL TO: True if the left operand is less than or equal to the right | x <= y

Now let's see each relational operator one by one
    1. ) GREATER THAN: This operator returns True if the left operand is great than the right
---SHELL---
a= 9
b= 5
print(a > b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
True

Process finished with exit code 0

    2. ) LESS THAN: This operator return True if the left operand is less than the right operand
---SHELL---
a = 9
b = 5
print(a < b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
False

Process finished with exit code 0

    3. ) EQUAL TO: This operator returns True if both the operands are equal, if both the left and the right operand are equal to each other
---SHELL---
a = 9
b = 5
print(a == b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
False

Process finished with exit code 0

    4. ) NOT EQUAL TO: This operator return True if both the operands are not equal
---SHELL---
a = 9
b = 5
print(a != b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
True

Process finished with exit code 0

    5. ) GREATER THAN OR EQUAL TO: This operator returns True if the left operand is greater than or equal to the right operand
---SHELL---
a = 9
b = 5
print(a >= b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
True

Process finished with exit code 0

    6.) LESS THAN OR EQUAL TO: This operator return True if the left operand is less than or equal to the right operand
---SHELL---
a = 9
b = 5
print(a <= b)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
False

Process finished with exit code 0

WHILE LOOPS
05272023_914: A while loop cannot have a ' else: ' statement in it. It will throw a silly looking error

Is used to execute a block of statements repeatedly until a given condition is satisfied. And when the condition becomes false, the line immediately after the loop in the program is executed.

FLOWCHART OF WHILE LOOP


        enter while loop
         |
         |
   _____test expression___False___
  |      |                        |
  |      |                        |
  |      True                     |
  |      |                        |
  |      |                        |
  |_____statements                exit while loop

While loops falls under the category of indefinite iteration. Indefinite Iteration means that the number of times the loop is executed isn't specified explicitly in advance. Statements represent all the statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as it's method of grouping statements. When a while loop is executed, expr is first evaluated in a Boolean context and if it is true, the loop body is executed. Then the expr is checked again, if it is still true then the body is executed again and this continues until the expression becomes false.

' indefinite iteration ' - Condition-controlled iteration is when a set of instructions is repeated based on whether a condition evaluates as True or False. Types of condition-controlled iteration include while loops, do while loops, and repeat until loops.

WHILE LOOP EXAMPLE
---SHELL---
count = 0
while (count < 3):
    count = count + 1
    print('hello geek')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
hello geek
hello geek
hello geek

Process finished with exit code 0

In the above example, the condition for while will be True as long as the counter variable (count) is less than 3.

COUNTING
' count ' - They don't really go in-depth about this in the guide but you can make Python count by setting a variable to itself + 1 here is an example:
---SHELL---
AVariable = 1
while (AVariable < 10):
    AVariable = AVariable + 1
    print(AVariable)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
2
3
4
5
6
7
8
9
10

Process finished with exit code 0

---SHELL---
day = 0
while(day < 21): day += 1; print('%d less days until your habit is establish' % (day))
else:
    print('your habit is established')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
1 less days until your habit is establish
2 less days until your habit is establish
3 less days until your habit is establish
4 less days until your habit is establish
5 less days until your habit is establish
6 less days until your habit is establish
7 less days until your habit is establish
8 less days until your habit is establish
9 less days until your habit is establish
10 less days until your habit is establish
11 less days until your habit is establish
12 less days until your habit is establish
13 less days until your habit is establish
14 less days until your habit is establish
15 less days until your habit is establish
16 less days until your habit is establish
17 less days until your habit is establish
18 less days until your habit is establish
19 less days until your habit is establish
20 less days until your habit is establish
21 less days until your habit is establish
your habit is established

Process finished with exit code 0

WHILE LOOP WITH LIST
---SHELL---
a = [1,2,3,4]

while a:
    print(a.pop())

b = ['dog','cat','racoon','mouse']

while b:
    print(b.pop())

---TERMINAL----
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0308_808.py
4
3
2
1
mouse
racoon
cat
dog

Process finished with exit code 0

In the above example, we have run a while loop over a list that will run until there isn't an element present in the list.

SINGLE STATEMENT 'WHILE' BLOCK
Just like the if block, if the while block consists of a single statement we can declare the entire loop in a single line. If there are multiple statements in the block that makes up the loop body, they can be separated by semicolons

' += ' - This means to add and set equal to the sum, so if the count = 0, count += 1 will make the count = 1 and then running count += 1 again will make the count = 2. Doing it with just +, count + 1 will make count = 1 and if you do count + 1 again count = 1 still because your just repeated adding 1 to 0 which is 1 not adding 1 to the sum of count + 1.

---SHELL---
count = 0
while (count < 5): count += 1; print('hello geek')

---TERMINAL---
"count += 1" add and make equal to, so it will add one to the count making the count 1 which is still less that 5 so it will print but then on the next loop it will add 1 to count making it equal 2. With just the addition sign it will keep adding one to 0 which is what the count is set at.
hello geek
hello geek
hello geek
hello geek
hello geek

Process finished with exit code 0

LOOP CONTROL STATEMENTS
Loop control statements change execution from it normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements

CONTINUE STATEMENT
Python Continue Statement returns the control to the beginning of the loop.

---SHELL---
i = 0
a = 'geeksforgeeks'

while i < len(a):
    if a[i] == 'e' or a[i] == 's':
        i += 1
        print(i)
        continue

    print('current letter :', a[i])
    i += 1

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
current letter : g
2
3
current letter : k
5
current letter : f
current letter : o
current letter : r
current letter : g
10
11
current letter : k
13

Process finished with exit code 0

- With this piece of code there is a decent concept to highlight and that is that this provides a counter for each specific character in a string while also printing or doing a function for every character that is not that counted character. This is like a Dual Function ' Count and Print Other '. Trying to think what this could be good for. Perhaps listing things that aren't done and dismissing things that are. Lets give that a try.

' while ' - Use this in place of ' if ' and it will repeat what would have been the singular if statement until the statement is not True.

LIST OBJECT ON EACH LINE
---SHELL---
Tasks = ['[]clean the room','[]clean the filled room','[]put the chest in the bedroom','[]light the garage','[]power the garage','[X] figure out how to list the things that are or arent done']

Taskscount = 0
while (Taskscount < len(Tasks)):
    Taskscount += 1
    print(Tasks[Taskscount])

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
[]clean the filled room
[]put the chest in the bedroom
[]light the garage
[]power the garage
[X] figure out how to list the things that are or arent done
Traceback (most recent call last):
  File "C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py", line 6, in <module>
    print(Tasks[Taskscount])
IndexError: list index out of range

BREAK STATEMENT
Brings control out of the loop

' stop listing at an object '
---SHELL---
names = ['bobby','brown','james','brown','NOTES','michael','brown',]

while namesCOUNT<len(names):
    if names[namesCOUNT] == 'NOTES':
        i += 1
        break
    print('current object: %s' % (names[namesCOUNT]))
    namesCOUNT += 1

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
current object: bobby
current object: brown
current object: james
current object: brown

Process finished with exit code 0

PASS STATEMENT
The Python PASS STATEMENT is to write empty loops. Pass is also used for empty control statements, functions, and classes
---SHELL---
a = 'geeksforgeeks'
i = 0

while (i<len(a)):
    i += 1
    print('Value of i: %d' % (i))
    pass

b = 'hoonigan'
i = 0

while (i<len(b)):
    i += 1
    print('Value of i: %d' % (i))
    continue

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
Value of i: 1
Value of i: 2
Value of i: 3
Value of i: 4
Value of i: 5
Value of i: 6
Value of i: 7
Value of i: 8
Value of i: 9
Value of i: 10
Value of i: 11
Value of i: 12
Value of i: 13
Value of i: 1
Value of i: 2
Value of i: 3
Value of i: 4
Value of i: 5
Value of i: 6
Value of i: 7
Value of i: 8

Process finished with exit code 0

WHILE LOOP WITH ELSE
As discussed above, while loop executes the block until a condition is satisfied. When the condition becomes false, the statement immediately after the loop is executed. The else clause is only executed when your while condition becomes false. If you break out of the loop, or if an exception is raise it won't be executed. The else block just after for/while is executed only when the loop is NOT terminated by a break statement.

---SHELL---
i = 0
while i<4:
    i += 1
    print(i)
else:
    print('above four, the break in the next program stops the else from executing as well as the while loops from repeating past one')

i = 0
while i<4:
    i += 1
    print(i)
    break
else:
    print('above four')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
1
2
3
4
above four, the break in the next program stops the else from executing as well as the while loops from repeating past one
1

Process finished with exit code 0

SENTINEL CONTROLLED STATEMENT
In this, we don't use any counter variable because we don't know how many times the loop will execute. Here user decides that how many times he wants to execute the loop. For this, we use a sentinel value. A sentinel value is a value that is used to terminate a loop whenever a user enters it, generally, the sentinel value is negative one.

' Sentinel Value ' - A value that is used to terminate a loop whenever a user enters it
---SHELL---
a = int(input('enter a number 1-10 (-1 to quit): '))
while a > 0 or a < 10:
    a = int(input('Enter a number 1-10 (-1 to quit): '))
    if a == 1:
        a = input('What is your favorite ice cream?: ')
    elif a == 2:
        a = input('What is your favorite wrestler?: ')
    elif a == 3:
        a = input('What is your favorite dog?: ')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
enter a number 1-10 (-1 to quit): 2
Enter a number 1-10 (-1 to quit): 2
What is your favorite wrestler?:

WHILE LOOP ON BOOLEAN VALUE
One common use of boolean values in while loops is to create an infinite loop that can only be exited based on some condition within the loop, for example:
---SHELL---
count=0

while True:
    count += 1
    print(f'count is {count}')

    if count == 10:
        break
print('the loop has ended')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
count is 1
count is 2
count is 3
count is 4
count is 5
count is 6
count is 7
count is 8
count is 9
count is 10
the loop has ended

Process finished with exit code 0

In this example we initialize a counter and then use an infinite loop (true is always true) to increment the counter and print it's value. We check if the counter has reached a certain value and if so, we exit the loop using the break statement.

LOGICAL NOT
The NOT keyword is a logical operator which is usually used for figuring out the negation or opposite boolean value of the operand. The Keyword ' NOT ' is a unary type operator which means that it takes only one operand for the logical operation and returns the complementary of the boolean value of the operand. For example if we will give false as an operand to the not keywords we get true as the value of returns

PRACTICAL APPLICATION
The possible practical application of NOT keyword are: - This keyword is mostly used for altering the boolean value. - It is used with an ' if ' statement. In the if statement it is used for negating the condition. - NOT keyword is also used with in keyword. It is used with in keyword when we are searching for the specific value in the collection of data.
---SHELL---
a = True
print(not a)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
False

Process finished with exit code 0

---SHELL---
a = False
print(not a)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
True

Process finished with exit code 0

As basic property of the NOT keyword is that is it used to invert the truth value of the operand. So we can see here that the result of every value is inverted from their true value. At #5 we can see the compare operation result would be false, so negation of it if we get True value.Similar, we can see all results are inverted

---SHELL---
geek_x = not False
print('negation of False: %s' % (geek_x))

geek_y = not True
print('Negation of True: %s' % (geek_y))

geek_and = not (True and False)
print('negation of result of And operation: %s' % (geek_and))

geek_or = not (True or False)
print('negation of result of or operation: %s' % (geek_or))

geek_Com = not (5 > 7)
print('Negation of result of And operation: %s' % (geek_Com))

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
negation of False: True
Negation of True: False
negation of result of And operation: True
negation of result of or operation: False
Negation of result of And operation: True

Process finished with exit code 0

---SHELL----
geek_Str = 'geek'
print('negation of string: ',not geek_Str)

geek_List = [1,2,3,4]
print('negation of list: ',not geek_List)

geek_Dict = {'geek':'sam','collage':'Mit'}
print('negation of dictionary: ',not geek_Dict)

geek_EDict = ''
print('negation of an empty string: ', not geek_EDict)

geek_EList = []
print('negation of a empty list: ',not geek_EList)

geek_EStr = {}
print('negation of empty dictionary: ', not geek_EStr)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
negation of string:  False
negation of list:  False
negation of dictionary:  False
negation of an empty string:  True
negation of a empty list:  True
negation of empty dictionary:  True

Process finished with exit code 0

In the above example we had seen that treat all the data types as operand with not keyword, 'not' treats true to all the data types who had value and false to those who were empty value

---SHELL---
geek_list = [5,10,20,59,134,83,95]
if len(geek_list) > 20:
    print('this is the geek list')
elif not geek_list:
    print('inputted list is empty')
else:
    for i in geek_list:
        if not(i % 5):
            if i not in (0,10):
                print('multiple is not in range')
            else:
                print(i)
        else:
            print('the number is not multiple of 5')

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
multiple is nto in range
10
multiple is nto in range
the number is not multiple of 5
the number is not multiple of 5
the number is not multiple of 5
multiple is nto in range

Process finished with exit code 0

FOR LOOPS
These are used for sequential traversal i.e. it is used for iterating over and iterable like string, tuple, list, set or dictionary. In Python, there is no C style for loop i.e., for (i=-; i<n; i++). There is FOR loop which is similar to each loop in other languages. Let us learn how to use for in loop for sequential traversals. In python, for loops only implements the collection-based iteration.

FOR LOOPS SYNTAX
for var in iterable:
    # statements

FOR LOOPS FLOWCHART


     each item in sequence
        |
        |
   ___last item___True___
  |   reached ?         |
  |      |              |
  |      |          exit for
  |    False          loop
  |      |
  |      |
  |__run statement

Here the iterable is a collection objects like lists, tuples. The indented statements inside the for loops are executed once for each item in an iterable. The variable var takes the value of the next item of the iterable each time through the loop.

FOR LOOP EXAMPLES
i = iterations in FOR LOOPS

' print list on separate lines '
---SHELL---
l = ['geeks','noms','loops']
for i in l:
    print(i)

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
geeks
noms
loops

Process finished with exit code 0

USING FOR LOOPS IN PYTHON DICTIONARY
---SHELL---
print('dictionary iteration')
d = dict()
d['xyz'] = 123
d['abc'] = 345
for i in d:
    print("%s %d" % (i,d[i]))

---TERMINAL---
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
dictionary iteration
xyz 123
abc 345

Process finished with exit code 0

USING FOR LOOPS IN A PYTHON STRING
---SHELL---
print('string iteration')
s = 'geeks'
for i in s:
    print(i)

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
string iteration
g
e
e
k
s

Process finished with exit code 0

LOOP CONTROL STATEMENTS
Loop control statements change from it normal sequence. When execution leaves a scope, all automatic objects that we're created in that scope are destroyed. Python supports the following control statements.

CONTINUE STATEMENT
Python continue returns the control to the beginning of the loop
===SHELL===
for letter in 'geeksforgeeks':
    if letter == 'e' or letter == 's':
        continue
    print('CONTINUE stops the letter from printing')
    print('\tcurrent letter: ',letter)

for letter in 'geeksforgeeks':
    if letter == 'e' or letter == 's':
        pass
    print('PASS allows the letter to print')
    print('\tcurrent letter: ',letter)

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
CONTINUE stops the letter from printing
	current letter:  g
CONTINUE stops the letter from printing
	current letter:  k
CONTINUE stops the letter from printing
	current letter:  f
CONTINUE stops the letter from printing
	current letter:  o
CONTINUE stops the letter from printing
	current letter:  r
CONTINUE stops the letter from printing
	current letter:  g
CONTINUE stops the letter from printing
	current letter:  k
PASS allows the letter to print
	current letter:  g
PASS allows the letter to print
	current letter:  e
PASS allows the letter to print
	current letter:  e
PASS allows the letter to print
	current letter:  k
PASS allows the letter to print
	current letter:  s
PASS allows the letter to print
	current letter:  f
PASS allows the letter to print
	current letter:  o
PASS allows the letter to print
	current letter:  r
PASS allows the letter to print
	current letter:  g
PASS allows the letter to print
	current letter:  e
PASS allows the letter to print
	current letter:  e
PASS allows the letter to print
	current letter:  k
PASS allows the letter to print
	current letter:  s

Process finished with exit code 0

BREAK STATEMENT IN PYTHON
Python BREAK statement brings control out of the loop:
===SHELL===
for letter in 'geeksforgeekjs':
    if letter == 'j' or letter == 'p':
        break
    print('current letter: ', letter)

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
current letter:  g
current letter:  e
current letter:  e
current letter:  k
current letter:  s
current letter:  f
current letter:  o
current letter:  r
current letter:  g
current letter:  e
current letter:  e
current letter:  k

Process finished with exit code 0

' print completed tasks '
===SHELL===
MusicRoom=['[]Get it Ready','[]Set up DrumSet','[X]Determine power needs','[]Big Ass Rug','[X]Audio Input/Output Diagram']

for i in MusicRoom:
    if i[0:3] == '[X]':
        print(i)

===TERMINAL===
MusicRoom=['[]Get it Ready','[]Set up DrumSet','[X]Determine power needs','[]Big Ass Rug','[X]Audio Input/Output Diagram']

for i in MusicRoom:
    if i[0:3] == '[X]':
        print(i)

FOR LOOP WITH PASS STATEMENT
The pass statement to write empty loops. Pass is also used for empty control statements, functions and classes

===SHELL===
for letter in 'geeksforgeeks':
    pass
print('pass last letter: ', letter)

for letter in 'moregeeks':
    continue
print('continue last letter: ', letter)

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
pass last letter:  s
continue last letter:  s

Process finished with exit code 0

RANGE FUNCTION IN PYTHON
Python ' range() ' is a built-in function that is used when a user needs to perform an action a specific number of times. range() in Python 3+ is just a renamed version of a function called
' xrange() ' in Python 2+. The ' range() ' function is used to generate a sequence of numbers. Depending on how many arguments the user is passing to the function, user can decide where that series of number will begin and end as well as how big the difference will be between one number and the ' next.range() ' takes mainly three arguments. 1. ) - START - Integer starting from which the sequence of integers is to be returned. 2. ) STOP - Integer before which the sequence of integers is to be returned. The range of integers. 3. ) - STEP - Integer value which determines the increment between each integer in the sequence.

PYTHON FOR LOOP WITH RANGE FUNCTION
===SHELL===
for i in range(10):
    print(i,end=' ')
sum = 0
for i in range(1,10):
    sum = sum + i
print("\nSum of the first 10 numbers : ", sum)

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
0 1 2 3 4 5 6 7 8 9
Sum of the first 10 numbers :  45

Process finished with exit code 0

FOR LOOPS IN PYTHON WITH ELSE
In most programming languages (C/C++, Java,etc) the use of else statements has been restricted with the if conditional statements. But Python also allows us to use the else condition with loops. The else block just after for/while is executed only when the loop is NOT terminated by a break statement
===SHELL===
for i in range(1,4):
    print(i)
else:
    print('no break')

===TERMINAL===
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0309_820.py
1
2
3
no break

Process finished with exit code 0

NESTED LOOPS
There are two types of loops which are ' for loops '  and  ' while loops '. Using these loops we can create nested loops in Python. Nested loops mean loops inside a loop. For example, while loop inside for for loop, for loop inside the for loop, etc.

' nested loops ' - Loops inside of loops

PYTHON NESTED LOOP DIAGRAM


            PYTHON NESTED LOOP

                 for i in range(2):   ___
                 print(i)                |
   Inner Loop-___for j in range(10,13):  |-outer loop
              |__print(i)             ___|

In python, programming language there are two types of loops while are for long and while loop. Using there loops we can create nested loops in Python. Nested loops mean loops inside a loop. For example, while loop inside the for loop, for loop inside the for loop, etc.

SYNTAX
Outer_loop Expression:
    Inner_loop Expression:
        Statement inside inner_loop:

Statement inside Outer_loop

PYTHON NESTED LOOP EXAMPLES
SHELL___
x = [1,2]
y = [4,5]

for i in x:
    for j in y:
        print(i,j)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0313_1418.py
1 4
1 5
2 4
2 5

Process finished with exit code 0
- THis is interesting because the nested loops pairs all variables with each other that are possible, interested in what this can be used for.

PRINTING MULTIPLICATION TABLE USING PYTHON NESTED FOR LOOPS
EVERY DAY IN A WEEK FOR EVERY WEEK
SHELL___
for i in range(1,5):
    for j in range(1,8):
        print(i, '*', j, "=", i*j)
    print()

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0313_1418.py
1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
1 * 4 = 4
1 * 5 = 5
1 * 6 = 6
1 * 7 = 7

2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14

3 * 1 = 3
3 * 2 = 6
3 * 3 = 9
3 * 4 = 12
3 * 5 = 15
3 * 6 = 18
3 * 7 = 21

4 * 1 = 4
4 * 2 = 8
4 * 3 = 12
4 * 4 = 16
4 * 5 = 20
4 * 6 = 24
4 * 7 = 28


Process finished with exit code 0

In the above example what we do is take an outer for loop running from 2 to 3 for multiplication table of 2 and 3 and then inside that loop we are taking an inner for loop that will run from
1 to 10 inside that we are printing multiplication table by multiplying each iteration value of inner loop with the iteration value of outer loop as we see in the below output.

PRINTING USING DIFFERENT INNER AND OUTER NESTED LOOPS
SHELL___
list1 = ['I am', 'You are ']
list2 = ['healthy', 'fine', 'geek']

list2_size=len(list2)

for item in list1:
    print('start outer for loop')
    i = 0
    while(i < list2_size):
        print(item, list2[i])
        i = i+1
    print('end for loop')

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0313_1418.py
start outer for loop
I am healthy
I am fine
I am geek
end for loop
start outer for loop
You are  healthy
You are  fine
You are  geek
end for loop

Process finished with exit code 0

SHELL___
list1 = ['I am', 'You are ']
list2 = ['healthy', 'fine', 'geek']

list2_size=len(list2)

for item in list1:
    print('start outer for loop')
    i = 0
    while(i < list2_size):
        print(item, list2[i])
        i = i+1
    print('end for loop')

#Essentially this code it taking two phrases that apply to a self and an other, i am and u are, and then applying the same 3 states to either. This can be effective in my code if I wanted to apply the same set of circumstances to two different items
print('\nThis is my version according to the psuedocode:\n')
date=['completed: march 13 at 2:40pm']
rooms=['office','bedroom','living room','kitchen']

RoomSize=len(rooms)
for item in date:
    print('these are the dates in the outer loop')
    i = 0
    while(i<RoomSize):
        print(item, rooms[i])
        i = i+1
    print('end for loop')

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0313_1418.py
start outer for loop
I am healthy
I am fine
I am geek
end for loop
start outer for loop
You are  healthy
You are  fine
You are  geek
end for loop

This is my version according to the psuedocode:

these are the dates in the outer loop
completed: march 13 at 2:40pm office
completed: march 13 at 2:40pm bedroom
completed: march 13 at 2:40pm living room
completed: march 13 at 2:40pm kitchen
end for loop

Process finished with exit code 0

In this example, we are initializing two lists with some strings. Store the size of list2 in 'list2_Size' using len() function and using it in the while loop as a counter. After that run an outer for loop to interate over list1 and inside that loop run an inner while loop to iterate over list2 using list indexing inside that we are printing each value of list2 for every value of list1.

USING BREAK STATEMENT IN NESTED LOOPS
It is a type of loop control statement. In a lop, we can use the break statement to exit from the loop. When we use a break statement in a loop it skips the rest of the iteration and terminates the loop. Let's understand it using an example.

SHELL___
for i in range(2,4):
    for j in range(1,11):
        if i==j:
            break
        print(i, '*', j, '=', i*j)
    print()

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0313_1418.py
2 * 1 = 2

3 * 1 = 3
3 * 2 = 6


Process finished with exit code 0

The above code is the same as in Example 2 in this code we are using a break statement inside the inner loop by using the if statement. Inside the inner loop if 'i' becomes equals to 'j' then the inner loop will be terminated and not executed that rest of the iteration as we can see in the output table of 3 is printed up to two iterations because in the next iteration 'i' becomes equal to 'j' and the loop breaks.

USING CONTINUE STATEMENT IN NESTED LOOPS
A continue statement is also a type of loop control statement. It is just the opposite of the break statement. THe continue statement forces the loop to jump to the next iteration of the loop wheras the break statement terminates the loop. Let's understand it by using code.

TYPE ERROR
'  int ' object is not iterable '
If you are running your Python code and you see this error, it means you are trying to loop through an integer or other data types that loops cannot work on. In Python, iterable data are lists, tuples, sets, dictionaries, and so on. In addition, this error being a 'typeerror' means you're trying to perform an operation on an inappropriate data type. For example, adding a string with an intefer. Today is the last day you should get this error while running your Python code. Because in this article, I will not just show you how to fix it, I will also show you how to check for the __iter__ magic methods so you can see if an object is iterable.

HOW TO FIX INT OBJECT IS NOT ITERABLE
If you are trying to loop through an integer, you will get this error:

SHELL___
count = 14

for i in count:
    print(i)

TERMINAL
# Output: TypeError: 'int' object is not iterable

One way to fix it is to pass the variable into the range() function. In Python, the range function checks the variable passed into it and returns a series of numbers starting from 0 and stopping right before the specified number. The loop will now run:

SHELL___
count = 14

for i in range(count):
    print(i)

TERMINAL
# Output: 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10
# 11
# 12
# 13

Another example that uses this solution is in the snippet below:

SHELL___
age = int(input("Enter your age: "))

for num in range(age):
    print(num)

TERMINAL
# Output:
# Enter your age: 6
# 0
# 1
# 2
# 3
# 4
# 5

HOW TO CHECK IF DATA OR AN OBJECT IS ITERABLE
To check if some particular data are iterable, you can use the dir() method. If you can see the magic method __iter__, the the data are iterable. If not, then the data are not iterable and you shouldn't bother looping through them.

SHELL___
perfectNum = 7

print(dir(perfectNum))

TERMINAL
# Output:['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__',
# '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']

The magic method __iter__ was found, so the list jerseyNums is iterable

CONCLUSION
In this article you learned about the 'Int Object is Not Iterable' error and how to fix it. You were also able to see that it is not possible to check whether an object or some data are iterable or not. If you check for the __iter__ magic method in some data and you don't find it, it's better to not attempt to loop through the data as all since they're not iterable. Thank you for reading.

USING CONTINUE STATEMENT IN NESTED LOOPS (Continued)
A continue statement is also a type of loop control statement. It is just the opposite of the break statement. THe continue statement forces the loop to jump to the next iteration of the loop whereas the break statement terminates the loop. Let's understand it by using code.

' range ' - includes the first number buts stops the number before the second so (2,4) only includes 2 and 3, 4 is excluded.

SHELL___
for i in range(2,4):
    for j in range(1,11):
        if i==j:
            continue
        print(i, "*",j,"=", i*j)
    print()

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
2 * 1 = 2
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14
2 * 8 = 16
2 * 9 = 18
2 * 10 = 20

3 * 1 = 3
3 * 2 = 6
3 * 4 = 12
3 * 5 = 15
3 * 6 = 18
3 * 7 = 21
3 * 8 = 24
3 * 9 = 27
3 * 10 = 30


Process finished with exit code 0

In the above code instead of using a break statement, we are using a continue statement. Here when 'i' become equal to 'j' in the inner loop it skips the rest of the code in the inner loop and jumps on the next interation as we see in the output "2 * 2 = 4" and "3 * 3 = 9" is not printed because at that point 'i' becomes equal to 'j'.

SINGLE LINE NESTED LOOPS USING LIST COMPREHENSION
To convert the multiline nested loops into a single line, we are going to use LIST COMPREHENSION in python. List comprehension includes brackets consisting of expression, which is executed for each element, and the for loop to iterate over each element in the list.

SYNTAX
newList=[[expression(element) for <element> in oldList if <condition>]

SHELL___
SINGLE LINE NESTED LOOPS EXAMPLE:
list1 = [[j for j in range(3)]
         for i in range(5)]
print(list1)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

Process finished with exit code 0

In the above code, we are storing a list inside the list using list comprehension in the inner loop of list comprehension[j for j in range(3)] to make a list [0,1,2] for every interation of the outer loop

' list comprehension ' - includes brackets consisting of expression, which is executed for each element, and the for loop to iterate over each element in the list.

PYTHON LISTS
Python Lists are just like dynamically sized arrays, declared in other languages(vector in C++ and ArrayList in Java). In simple language, a list is a collection on of things, enclosed in [] and separated by commas. The list sequence data type which is used to store the collection of data. Tuples and String are other types of sequence data types.

EXAMPLE OF A PYTHON LIST
Here we are creating Python List using []:

SHELL___
var=['geeks','for','geeks']
print(var)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
['geeks', 'for', 'geeks']

Process finished with exit code 0

Lists are the simplest containers that are an integral part of the Python language. Lists need not be homogenous always which make it the most powerful tool in Python. A single list may contain DataTypes liek integers, strings, as well as Objects. Lists are immutable, and hence, they can be altered even after their creation.

CREATING A LIST IN PYTHON
Lists in Python can be created by just placing the sequence inside the square brackets[]. Unlike Sets, a list doesn't need a built-in function for its creation of a list. Unlike sets, the list may contain multable elements.

' sets ' -

EXAMPLE 1: CREATING A LIST

SHELL___
listblank = []
print("blank list: ")
print(listblank)

ListNumbers=[10,20,40]
print('\nlist of numbers: ')
print(ListNumbers)

ListStrings=['geeks','for','geeks']
print('\nList Items: ')
print(ListStrings[0])
print(ListStrings[2])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
blank list:
[]

list of numbers:
[10, 20, 40]

List Items:
geeks
geeks

Process finished with exit code 0

EXAMPLE 2: CREATING A LIST WITH MULTIPLE DISTINCT OR DUPLICATE ELEMENTS
A list may contain duplicate values with their distinct position and hence, multiple distinct or duplicate values can be passed as a sequence at the the time of list creation.

SHELL___
List = [1,2,4,4,3,3,3,6,5]
print('\n list with the use of numbers: ')
print(List)

List = [1,2,'Geeks',4,'For',6,'Geeks']
print('\nList with the use of Mixed Values: ')
print(List)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py

 list with the use of numbers:
[1, 2, 4, 4, 3, 3, 3, 6, 5]

List with the use of Mixed Values:
[1, 2, 'Geeks', 4, 'For', 6, 'Geeks']

Process finished with exit code 0

ACCESSING ELEMENTS FROM THE LIST
In order to access the list items refer to the index number. Use the index operator [] to access an item in a list. The index must be an integer. Nested lists are accessed using nested indexing.

SHELL__
List = ['geeks','for','Geeks']
listcount=-1

while len(List) > 1:
    listcount += 1
    print(List[listcount][listcount])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
g
o
e
Traceback (most recent call last):
  File "C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py", line 6, in <module>
    print(List[listcount][listcount])
IndexError: list index out of range

SHELL___
Process finished with exit code 1

List = [['Geeks', 'For'], ['Geeks']]

print("Accessing a element from a Multi-Dimensional list")
print(List[0][0])
print(List[0][1])
print(List[1][0])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
Accessing a element from a Multi-Dimensional list
Geeks
For
Geeks

Process finished with exit code 0

NEGATIVE INDEXING
In Python, negative sequence indexes represent positions from the end of the array. Instead of having to compute the offset as in List[len(list)-3]. Negative indexing means beginning from the end, -1 refers to the last item, -2 refers to the second to last item

SHELL___
List = [1,2, 'Geeks',4,'FOR',6,'geeks']
print('accessing element using negative indexing: ')
print(List[-1])
print(List[-2])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
accessing element using negative indexing:
geeks
6

Process finished with exit code 0

GETTING THE SIZE OF THE PYTHON LIST
Python len() is used to specify the length of the list

SHELL___
List1 = []
print(len(List1))

List2 = [10,20,30]
print(len(List2))

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
0
3

Process finished with exit code 0

TAKING INPUT OF A PYTHON LIST
We can take the input of a list of elements as a string, integer, float, etc. But the default one is a string

SHELL___
goal = input('enter elements (space-separated): ')
GoalList = goal.split()
print(' the list is: ',GoalList)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
enter elements (space-separated): Eat only eggs at work
 the list is:  ['Eat', 'only', 'eggs', 'at', 'work']

Process finished with exit code 0

SHELL___
n = int(input('enter the size of list: '))
lst = list(map(int, input('enter the interger\elements').strip().split()))[:n]
print('the list is: ', lst)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\Documents\Education\Studies_0314_703.py
enter the size of list: 10
enter the interger\elements1 2 5 4 5 6 8 5 4 1
the list is:  [1, 2, 5, 4, 5, 6, 8, 5, 4, 1]

Process finished with exit code 0

ADD TO LIST
Elements can be added to the List by using the built-in append() function. Only one element at a time can be added to the list by using the append() method, for the addition of multiple elements with the append() method, loops are used. Tuples can also be added to the list with the use of the append method because tuples are immutable. Unlike Sets, List acn also be added to the existing list with the use of the append() method.

    SHELL___
List = []
print('initial blank list:')
print(List)

List.append(1)
List.append(2)
List.append(4)
print("\nList after addition of three elements:")
print(List)

for i in range(1,4):
    List.append(i)
print("\nList after addition of elements from 1-3: ")
print(List)

List.append((5,6))
print("\nList after Addition of a Tuple:")
print(List)

List2=['For','Geeks']
List.append(List2)
print('\nList after addition of a list:')
print(List)

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
initial blank list:
[]

List after addition of three elements:
[1, 2, 4]

List after addition of elements from 1-3:
[1, 2, 4, 1, 2, 3]

List after Addition of a Tuple:
[1, 2, 4, 1, 2, 3, (5, 6)]

List after addition of a list:
[1, 2, 4, 1, 2, 3, (5, 6), ['For', 'Geeks']]

Process finished with exit code 0

METHOD 2: USING insert() method
append() method only works for the addition of elements at the end of the List, for the addition of elements at the desired position, insert() method is used. Unlike append() which takes only one argument, the insert() method requires 2 arguments' (position, value) '.

    SHELL___
List= [1,2,3,4]
print("Initial List: ")
print(List)

List.insert(3,12)
List.insert(0,'Geeks')
print("\nList after performing Insert Operation: ")
print(List)

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
Initial List:
[1, 2, 3, 4]

List after performing Insert Operation:
['Geeks', 1, 2, 3, 12, 4]

Process finished with exit code 0

METHOD 3: USING extend() METHOD
Other than ' append() ' and ' insert() '  methods, theres one more method for the addition of elements, extend(), this method is used to add multiple elements at the same time at the end of the list.

    SHELL___
List = [1,2,3,4]
print("Initial List: ")
print(List)

List.extend([8,'geeks','always'])
print('\nList after performing Extend Operation: ')
print(List)

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
Initial List:
[1, 2, 3, 4]

List after performing Extend Operation:
[1, 2, 3, 4, 8, 'geeks', 'always']

Process finished with exit code 0

REVERSE A LIST
A list can be reversed by using the reverse() method in Python

    SHELL___
mylist=[1,2,3,4,5,'geek','Python']
mylist.reverse()
print(mylist)

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
['Python', 'geek', 5, 4, 3, 2, 1]

Process finished with exit code 0

REMOVING ELEMENTS FROM THE LIST
METHOD 1: USING remove() METHOD
Elements can be removed from the List by using the built-in remove() function but an error arises if the element doesn't exist in the list. remove() method only removes one element at a time, to remove a range of elements, the itereator is used. The remove() method removes the specified item.

    SHELL___
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
initial list:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

list after removal of two elements:
[1, 2, 3, 4, 7, 8, 9, 10, 11, 12]

Process finished with exit code 0

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
initial list:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

list after removal of two elements:
[1, 2, 3, 4, 7, 8, 9, 10, 11, 12]

Process finished with exit code 0

USING pop() METHOD
pop() function can also be used to remove and return an element from the list, but by default it removes only the last element of the list, to remove an element from a specific position of the List, the index of the element is passed as an argument to the pop() method.

    SHELL___
List = [1,2,3,4,5]

List.pop()
print('\nlist after popping an element: ')
print(List)

List.pop(2)
print("\nlist after popping a specific element: ")
print(List)

    TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py

list after popping an element:
[1, 2, 3, 4]

list after popping a specific element:
[1, 2, 4]

Process finished with exit code 0

SLICING OF A LIST
We can get substrings and sublist using a slice. In Python List, there are multiple ways to print the whole list with all the elements, but to print a specific range of element from the list, we use the Slice operation. Slice operation is perform on List with the use of a colon(:). To print element form beginning to a range use: ' [:Index] '. To print elements from end use: ' [:-Index] '.To print elements from a specific index till the end use: ' [Index:] '.To print the whole list in reverse order use: ' [::-1]' To print elements of list from rear end, use negative indexes


                    ___' start:end '____________
        1   2   3   |   5   6   7   8   9  10   |  12  13

        G   E   E   K   S   F   O   R   G   E   E   K   S

 beginning[:   -3  -4  -5  -6  -7  -8  -9 -10  -11 :]ending
                                    <-----------------[::-1]reverse

UNDERSTANDING SLICING OF LISTS
pr[0] accesses the first item, 2.
pr[-4] accesses the fourth item from the end,5.
pr[2:] accesses [5,7,11,13], a list of items from third to last.
pr[:4] accesses [5,7], a list of items from third to fifth
pr[1::2] accesses [3,7,13], alternate items, starting from the second item.

|SHELL|
List = ['g','e','e','k','s','f','o','r','g','e','e','k','s']
print('initial list:')
print(List)

sliced_list = List[3:8]
print("\nslicing elements in a range 3-8: ")
print(sliced_list)

sliced_list = List[5:]
print('\nElements slice from 5th element til the end')
print(sliced_list)

sliced_list = List[:]
print('\nprinting all elements using the slice operation: ')
print(sliced_list)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
initial list:
['g', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'g', 'e', 'e', 'k', 's']

slicing elements in a range 3-8:
['k', 's', 'f', 'o', 'r']

Elements slice from 5th element til the end
['f', 'o', 'r', 'g', 'e', 'e', 'k', 's']

printing all elements using the slice operation:
['g', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'g', 'e', 'e', 'k', 's']

Process finished with exit code 0

NEGATIVE INDEX LIST SLICING

|SHELL|
List = ['g','e','e','k','s','f','o','r','g','e','e','k','s']
print('initial list:')
print(List)

sliced_list = List[:-6]
print("\nslicing elements for 6th to last: ")
print(sliced_list)

sliced_list = List[-6:-1]
print('\nElements sliced from index -6 to -1: ')
print(sliced_list)

sliced_list = List[::-1]
print('\nprinting list in reverse: ')
print(sliced_list)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
initial list:
['g', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'g', 'e', 'e', 'k', 's']

slicing elements for 6th to last:
['g', 'e', 'e', 'k', 's', 'f', 'o']

Elements sliced from index -6 to -1:
['r', 'g', 'e', 'e', 'k']

printing list in reverse:
['s', 'k', 'e', 'e', 'g', 'r', 'o', 'f', 's', 'k', 'e', 'e', 'g']

Process finished with exit code 0

LIST COMPREHENSION
List comprehensions are used for created new lists from other iterable like tuples, strings, arrays, list, etc.  A list comprehension consists of brackets containing the expression, which is executed for each element along with the for loop to iterate over each element.

SYNTAX
newList = [expression(element)for element in oldList if condition

' odd ' - ' x%2==1 ' this means when the number is divided by two the remainder is one, which can only happen with an odd number.

|SHELL|
odd_square = []

for x in range(1,11):
    if x % 2 == 1:
        odd_square.append(x**2)

print(odd_square)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
[1, 9, 25, 49, 81]

Process finished with exit code 0

|SHELL|
oddsquare=[x**2 for x in range(1,11) if x % 2 == 1]
print(oddsquare)

trialrun=[x**3 for x in range(1,10) if x % 2 == 1]
print(trialrun)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
[1, 9, 25, 49, 81]
[1, 27, 125, 343, 729]

Process finished with exit code 0

DETAILED LIST INFORMATION:_https://www.geeksforgeeks.org/python-lists/_

[] Python List Comprehension and Slicing
[] Nested List Comprehensions in Python
[] List comprehension and ord() in Python
[] Basic Example on Python List
[] Python program to interchange first and last elements in a list
[] Python program to swap two elements in a list
[] Python – Swap elements in String list
[] Python | Ways to find length of list
[] Maximum of two numbers in Python
[] Minimum of two numbers in Python

PYTHON LIST COMPREHENSION AND SLICING
List comprehension is an elegant way to define and create a list python. We can create list just like mathematical statements and in one line only. The syntax of list comprehension is easier to grasp. A list of comprehension generally consists of these parts: 1.) Output expression, 2.) Input sequence, 3.) A variable representing a member of the input sequence and 4.) an optional predicate part. For example:

list = [x ** 2 for x in range(1,11)  if x % 2 == 1]

1.) output expression -' x ** 2 '
2.) input expression -' range(1,11) '
3.) variable -' x '
4.) predicate part - ' if x % 2 == 1 ' - the verb is 'if', which is to decide and the information needed to make the decision is ' x % 2 == 1 ' saying the remainder of x/2 has to be one to satisfy the if statement.

' predicate ' - The part of a sentence of clause containing a verb and stating something about the subject

ANOTHER EXAMPLE:
list=[x**2 if x%2==1 else x*2 for x in range(1,11)]

|SHELL|
list=[x**2 if x%2==1 else x*2 for x in range(1,11)]
print(list)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch.py
[1, 4, 9, 8, 25, 12, 49, 16, 81, 20]

Process finished with exit code 0

APPEND USED INTERESTINGLY
' .append ' - Only one element at a time can be added to the list by using the append() method, for the addition of multiple elements with the append() method, loops are used. Tuples can also be added to the list with the use of the append method because tuples are immutable. Unlike Sets, List acn also be added to the existing list with the use of the append() method. append() method only works for the addition of elements at the end of the List.

|SHELL|
oddsquare=[]
for x in range(1,11):
    if x % 2 == 1:
        oddsquare.append(x**2)
print(oddsquare)

- It states that .append() can only be used to add statements to the end of a list. At first it seems like the code above was inserting that information to the list but I think because the list is empty is it not actually populated with the range(1,11) and replacing the number after they are modified with the append command. Its saying for ' x ' in the range(1,11) or ' one through 10 ', if x divided by 2 has a remainder of 1 then, append the list oddsquare by putting targeted numbers(odd numbers) to the power of two. But this should suggest that the even number would still be included in the list. Why is it that the even numbers are excluded and the off number to the power of 2 are included? I see, because ' x  ' is not defined until the end of the command none of the numbers from the range(1,11) would ever appear in the list because we don't know if they are equal to x before x is defined. So x has to meet all the requirements stated in the code before it can be derived so only the odd numbers to the power of 2 can be in the list because the meet the requirements to be x.

PYTHON | USING 2D ARRAYS/LISTS THE RIGHT WAY
Python provides many ways to create 2-dimensional lists/arrays. However, one must know the differences between these ays because they can create complication in code that can be very difficult to trace out. Let's start by looking at common ways of creating a 1D array of size N initialized with 0s.

USING 2D ARRAYS/LISTS THE RIGHT WAY (ARRAYS)
METHOD 1: CREATING 1D LIST
- Creating a 1D list using naive methods:

|SHELL|
N = 5
ar = [0]*N
print(ar)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[0, 0, 0, 0, 0]

Process finished with exit code 0

- This is stating that ' N ' is equal to ' 5 ' and that ar is a list and the list is equal to 0, the only element in the list to the power of ' N ', which is ' 5 ' and to print the resulting list which is 5 ' 0's '. So we can see that if you put a list to the power of something else it will create elements of that thing multiplied in the list. Another example:

|SHELL|
thenumber=75
thelist=[2]
thepowering=(thelist)*thenumber
print(thepowering)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]

Process finished with exit code 0

- Creating a 1D list using list comprehension:

|SHELL|
N = 5
arr =[0 for i in range(N)]
print(arr)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[0, 0, 0, 0, 0]

Process finished with exit code 0

- This one is using that list comprehension idea and its saying that ' N ' is 5 and the list ' arr ' is equal ' 0 ' for every iteration(i) in the range of (N). Now I'm not quite sure why it assumes that the range is from 1-5 from the number alone but that seems to be the case.

EXPLANATION
Here we are multiplying the number of rows by the empty list and hence the entire list is created with every element zero.

METHOD 2: CREATING A 2-D LIST
EXAMPLE 1: NAIVE METHOD
|SHELL|
cols, rows = (5,5)
arr = [[0]*cols]*rows
print(arr)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

Process finished with exit code 0

This one is interesting it's asking for 5 five rows of 5 columns with the columns being separate lists, suggesting a very feint idea of vertical.

EXPLANATION
Here we are multiplying the number of columns and hence we are getting the 1D list of size equal to the number of columns and then multiplying it with the number of rows which results in the creation of a 2-D list. SOMETHING TO BE CAREFUL: Using this method can sometimes cause unexpected behaviors. In this method, each row will be referencing the same column. This means, even if we update only one element of the array, it will update same column in our array

|SHELL|
rows, cols = (5,5)
arr = [[0]*cols]*rows
print(arr, 'before')

arr[0][0] = 1 # update only one element
print(arr,'after')

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] before
[[1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]] after

Process finished with exit code 0

EXAMPLE 2: USING LIST COMPREHENSION

|SHELL|
rows, cols = (5,5)
arr = [[0 for i in range(cols)] for j in range(rows)]
print(arr)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

Process finished with exit code 0

EXPLANATION
Here we are basically using the concept of list comprehension and applying loop for a list inside a list and hence creating a 2-D list.

EXAMPLE 3: USING EMPTY LIST
|SHELL|
arr = []
rows, cols=5,5
for i in range(rows):
    col = []
    for j in range(cols):
        col.append(0)
    arr.append(col)
print(arr)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

Process finished with exit code 0

EXPLANATION
Here we are appending zeros as elements for number of columns times and then appending this 1-D list into the empty row list and hence creating the 2-D list.

|SHELL|
print('this method changes the same position for every row\n____________________')
rows, cols = (5,5)
arr = [[0]*cols]*rows
arr[0][0] = 1
for row in arr:
    print(row)

print('list comprehension can change just one element this way\n____________________')
arr = [[0 for i in range(cols)] for j in range(rows)]

arr[0][0] = 1
for row in arr:
    print(row)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
this method changes the same position for every row
____________________
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
list comprehension can change just one element this way
____________________
[1, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]

EXPLANATION
We expect only the first element of the first row to change to 1 but the first element of every row gets changed to 1 in method 2a. This peculiar functioning is because Python uses shallow lists which we will try to understand. In method 1a, Python doesn't create 5 integer objects but create only one integer objects and all the indices of the array ' arr ' point to the same ' int ' object as shown.

' shallow lists ' - Python doesn’t create 5 integer objects but creates only one integer object and all the indices of the array arr point to the same int object as shown.


        | 0 | 1 | 2 | 3 | 4 | 5 |
          |   |   |   |   |   |____________
          |   |   |   |   |_______________|_______
          |   |   |   |_____________| int object |
          |   |   |_________________|___value:0__|
          |   |_______________________|   |
          |_______________________________|

If we assign the 0th index to another integer, say 1, then a new integer object is created with the value of 1 and then the 0th index now points to this new int object as shown below.


        | 0 | 1 | 2 | 3 | 4 | 5 |
          |   |   |   |   |   |
          |   |___|___|___|___|
          |   |  int object   |
          |   |___value:0_____|
          |_____________
          | int object |
          |__value:0___|


Similarly, when we create a 2D array as ' arr=[[0]*cols]*rows ' we are essentially extending the above analogy. 1.) Only one integer object is created. 2.) A single 1D list is created and all its indices point to the same int object in point 1. 3.) Now, arr[0], arr[1], arr[2] arr[n-1] all point to the same list object above in point 2.

The above setup can be visualize din the image below


        arr= |      arr[0]      |       arr[1]      |       arr[2]      |       arr[3]      |       arr[4]      |
                      |                   |                   |                   |                   |
                      |                   |                   |                   |                   |
                      |                   |                   |                   |                   |
                      |                   |____________       |       ____________|                   |
                      |________________________       |       |       |       ________________________|
                                              |       |       |       |       |
                                              |       |       |       |       |
                                          ____|_______|_______|_______|_______|____
                                          |            1D ARRAY OBJECT            |
                                          |   0   |   1   |   2   |   3   |   4   |
                                          |_______________________________________|
                                              |       |       |       |       |
                                              |       |_______|_______|       |
                                              |_______|   int object  |_______|
                                                      |_____value:0___|

Now lets change the first element in first row of 'arr'as arr[0][0] = 1. - arr[0] points to the single list object we create above. Remember arr1, arr2, arr[n-1] all point to the same list object too. The assignment of arr[0][0] will create a new int object with the value 1 and arr[0][0] will now point to this new int object and so will the others.


       arr= |      arr[0]      |       arr[1]      |       arr[2]      |       arr[3]      |       arr[4]      |
                      |                   |                   |                   |                   |
                      |                   |                   |                   |                   |
                      |                   |                   |                   |                   |
                      |                   |____________       |       ____________|                   |
                      |________________________       |       |       |       ________________________|
                                              |       |       |       |       |
                                              |       |       |       |       |
                                          ____|_______|_______|_______|_______|____
                                          |            1D ARRAY OBJECT            |
                                          |   0   |   1   |   2   |   3   |   4   |
                                          |_______________________________________|
                                              |       |       |       |       |
                                              |       |____   |_______|_______|___
                                        ______|_______    |   |    int object    |
                                        | int object |    |___|     value:0      |
                                        |__value:1___|        |__________________|

So when 2D arrays are create like this, changing values at a certain row will effect all the rows since there is essentially only one integer object and only one list object being referenced by all the rows of the array. As you would expect, tracing out errors cause by such usage of shallow lists is difficult. Hence the better way to declare a 2D array is:

|SHELL|
rows, cols=(5,5)
print([[0 for i in range(cols)]for j in range(rows)])

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

Process finished with exit code 0

' arr = [[0]*cols]*rows ' - This will print rows of 0's horizontally

' for row in arr: '
      print(row)    - This will print the rows of 0's vertically when entered after the code above.

This method creates 5 separate list objects, unlike method 2a. One way to check this is by using the 'is' operator which checks if the two operands refer to the same object

|SHELL|
rows, cols = (5,5)
arr=[[0 for i in range(cols)]for j in range(rows)]
print(arr[0] is arr[1])
arr = [[0]*cols]*rows
print(arr[0] is arr[1])

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
False
True

Process finished with exit code 0

LIST METHODS IN PYTHON
Python List methods has multiple methods to work with Python lists, below we've explained all the methods you can use with Python lists, for example: append(), copy(), insert() and more.

LIST METHODS
1 | append () | Used for appending and adding elements to the end of the list
2 | copy()    | It returns a shallow copy of a list
3 | clear()   | This method is used for removing all items from the list
4 | count()   | This method counts the elements
5 | extend()  | Adds each element of the iterable to the end of the list
6 | index()   | Returns the lowest index where the element appears
7 | insert()  | Inserts a given element at a given index in a list
8 | pop()     | Removes and returns the last value from the list or the given index value
9 | remove()  | Removes a given object from the list
10| reverse() | Reverses objects of the list in place
11| sort()    | Sort a list in ascending, descending or user-defined order
12| min()     | Calculates minimum of all the elements of a list
13| max()     | Calulates maximum of all the elements of a list

ADDING ELEMENTS IN LIST
APPEND - ' append() '
Used for appending and adding elements to list. It is used to add element to the last position of the list in Python. SYNTAX - <listname>.append(<element>) | thelist.append('a list item')

|SHELL|
thelist=['item one','item two','item three','item four']
thelist.append('item five')
print(thelist)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
['item one', 'item two', 'item three', 'item four', 'item five']

Process finished with exit code 0

INSERT - ' insert() '
Inserts an element at the specified position. SYNTAX - <listname.insert(<postition>,<element>) | thelist.insert(0,'a list item'). Position mentioned should be within the range of list, as in this case between 0 and 4, elsewise would throw IndexError.

|SHELL|
thelist=['item one','item two','item three','item four']
thelist.insert(2,'item two point five')
print(thelist)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
['item one', 'item two', 'item two point five', 'item three', 'item four']

Process finished with exit code 0

EXTEND - ' extend() '
Adds contents to from one list to the end of another. SYNTAX - <listname>.extend(<otherlistname>) | thelist.extend(OtherList)

|SHELL|
listone=[1,2,3]
listtwo=[10,11,12]
listone.extend(listtwo)
print(listone)

listtwo.extend(listone)
print(listtwo)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[1, 2, 3, 10, 11, 12]
[10, 11, 12, 1, 2, 3, 10, 11, 12]

Process finished with exit code 0

OTHER FUNCTIONS OF LIST
SUM - ' sum() ' - Calculates the sum of all the elements of the list. SYNTAX sum(list).

|SHELL|
listone=[1,2,3,4,5,6]
listtwo=['one','two','three','four','five','six']

print(sum(listone))

print('trying sum on strings wont work so list two cant be added')

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
21
trying sum on strings wont work so list two cant be added

Process finished with exit code 0

WHAT HAPPENS IF A NUMERIC VALUE IS NOT USED AS PARAMETER?
The sum is calculated only for numeric values, elsewise throws TpeError.

COUNT - ' count() '
Calculates total occurrence of a given element of List. SYNTAX - ' <thelistsname>.count(<element>)| listhasmanyintergerone.count(1)'

|SHELL|
listone = [1,2,3,4,5,6,7,8,9,1,1,1,7,7,5]
print(listone.count(1))

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
4

Process finished with exit code 0

LENGTH
Calculates the total length of the list. SYNTAX - len(list_name)

|SHELL|
list=[1,2,3,5,3,5,5,4,5,4,5,5,5,4]
print(len(list))

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
14

Process finished with exit code 0

INDEX - ' index() '
States the position of the specified element in the list. The start and End index are not necessary parameters. SYNTAX ' listone.index(element[,start[,end]]) '

|SHELL|
listone=[1,2,3,1,2,1,2,3,2,1]
print(listone.index(2,2))

listone=[1,2,3,1,2,1,2,3,2,1]
print(listone.index(2))

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
4
1

Process finished with exit code 0

MAX - ' max() '| MIN - ' min() '
Calculates minimum of all the elements of list. SYNTAX - ' min(iterables[,key])'

|SHELL|
listone=[1,2,3,1,2,1,2,3,2,1]
print(min(listone))
print(max(listone))

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
1
3

Process finished with exit code 0

DELETION OF LIST ELEMENTS
To delete one or more element, remove an element, many built-in functions can be used, such as pop() & remove() and keywords such as del

POP - ' pop() '
The index is not a necessary parameter, if not mentioned takes the last index. SYNTAX - ' list.pop([index]) '

|SHELL|
listone=[1,2,3,1,2,1,2,3,2,1]
print(listone.pop(2))
print(listone.pop)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
3
<built-in method pop of list object at 0x000002078FAF60C0>

Process finished with exit code 0

DELETE - ' del() '
Element to be deleted is mentioned using list name and index. SYNTAX - ' del list.[index] '

|SHELL|
listone=[1,2,3,1,2,1,2,3,2,1]
del listone[1]
print(listone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[1, 3, 1, 2, 1, 2, 3, 2, 1]

Process finished with exit code 0

REMOVE - ' remove() '
element to be deleted is mentioned using list name and element

|SHELL|
listone=[1,2,3,1,2,1,2,3,2,1]
listone.remove(2)
print(listone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
[1, 3, 1, 2, 1, 2, 3, 2, 1]

Process finished with exit code 0

PYTHON TUPLES
Tuple is a collection of Python objects much like a list. The sequence of values stored in a tuple can be of any type, and they are indexed by integers. Values of a tuple are syntactically separated by 'commas'. Although it is not necessary, it is more common to define a tuple by closing the sequence of values in parentheses. This helps in understanding the Python tuples more easily.

CREATING A TUPLE
In python, tuples are created by placing a sequence of values separated by 'comma' with or without the use of parentheses for grouping the data sequence. Creation of python tuple without the use of parentheses is known as Tuple Packing

PYTHON PROGRAM TO DEMONSTRATE THE ADDITION OF ELEMENTS IN A TUPLE
SEPARATE A STRING
It seems you can separate a string into a tuple with each individual character being it's own element in the tuple

|SHELL|
tupleone = tuple('geeks')
print('\ntuple with the use of functions: ')
print(tupleone)

|TERMINAL|
tuple with the use of functions:
('g', 'e', 'e', 'k', 's')

|SHELL|
tupleone=()
print('initial empty tuples: ')
print(tupleone)

tupleone=('geeks','for')
print('\nTuple with the use of strings')
print(tupleone)

listone=[1,2,3,4,5,6]
print('\ntuple using list: ')
print(tuple(listone))

tupleone = tuple('geeks')
print('\ntuple with the use of functions: ')
print(tupleone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
initial empty tuples:
()

Tuple with the use of strings
('geeks', 'for')

tuple using list:
(1, 2, 3, 4, 5, 6)

tuple with the use of functions:
('g', 'e', 'e', 'k', 's')

Process finished with exit code 0

CREATING TUPLES WITH MIXED DATATYPES
Tuples can contain any number of elements and of any datatype. Tuples can also be created with a single element, but it is a bit tricky. Having one element in the parentheses is not sufficient, there must be a trailing 'comma'to make it a tuple.

|SHELL|
tupleone=(5,'welcome',7,'geeks')
print('tuple with mixed datatypes: ')
print(tupleone)

tupleone=(0,1,2,3,4)
tupletwo=('python','geek')
tuplethree=(tupleone,tupletwo)
print('\ntuple with nested tuple: ')
print(tuplethree)

tupleone=('geeks',)*3
print('\ntuple with repetition: ')
print(tuple(tupleone))

tupleone = ('geeks')
n = 5
print('tuple with a loop: ')
for i in range (int(n)):
    tupleone=(tupleone,)
    print(tupleone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
tuple with mixed datatypes:
(5, 'welcome', 7, 'geeks')

tuple with nested tuple:
((0, 1, 2, 3, 4), ('python', 'geek'))

tuple with repetition:
('geeks', 'geeks', 'geeks')
tuple with a loop:
('geeks',)
(('geeks',),)
((('geeks',),),)
(((('geeks',),),),)
((((('geeks',),),),),)

Process finished with exit code 0

ACCESSING OF TUPLES
tuple are immutable, and usually, they contain a sequence of heterogeneous elements that are accessed via 'unpacking' or indexing or even attribute in the case of named tuples. Lists are mutable, and their elements are usually homogenous and not accessed by iterating over the list. In unpacking of tuple number of variables on the left-hand side should be equal to a number of values in a give tuple a.

|SHELL|
tupleone = tuple('geeks')
print('first element of tuple: ')
print(tupleone[0])

print('it works this way too: ')
tupleone='geeks'
print(tupleone[0])

tupleone=('geeks','for','geeks')

a,b,c = tupleone
print('\nvalues after unpacking: ')
print(a)
print(b)
print(c)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
first element of tuple:
g
it works this way too:
g

values after unpacking:
geeks
for
geeks

Process finished with exit code 0

' unpacking ' - naming each element in a tuple a name separated by commas. This can then be printed according to the names given amongst the commas

CONCATENATION OF TUPLES
Concatenation of tuple is the process of joining two or more Tuples. Concatenation is done by the use of ' + ' operator. Concatenation of tuples is done always from the end of the original tuple. Other arithmetic operations do not apply on tuples. Only the same datatypes can be combined with concatenation, and error arises if a list and a tuple are combined.


                TUPLE 1                                     TUPLE 2
            | 0 | 1 | 3 | 3 |                       | geeks | for | geeks |

                                CONCATENATED TUPLE
                        | 0 | 1 | 3 | 3 | geeks | for | geeks |

|SHELL|
tupleone=(0,1,2,3)
tupletwo=('geeks','for','geeks')
tuplethree=tupleone+tupletwo
print('tuple one: ')
print(tupleone)
print('tuple two: ')
print(tupletwo)
print('tuple three: ')
print(tuplethree)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
tuple one:
(0, 1, 2, 3)
tuple two:
('geeks', 'for', 'geeks')
tuple three:
(0, 1, 2, 3, 'geeks', 'for', 'geeks')

Process finished with exit code 0

SLICING OF TUPLE
Slicing of a tuple is done to fetch a specific range or slice of sub-elements from a tuple. Slicing can also be done wo list and arrays. Indexing in a list results to fetching a single element wheras slicing allows to fetch a set of elements

|SHELL|
tupleone=tuple('GEEKSFORGEEKS')
print('removal of first element: ')
print(tupleone[1:])

print('tuple after sequence of element is reversed')
print(tupleone[::-1])

print('printing elements between range 4-9: ')
print(tupleone[4:9])

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
removal of first element:
('E', 'E', 'K', 'S', 'F', 'O', 'R', 'G', 'E', 'E', 'K', 'S')
tuple after sequence of element is reversed
('S', 'K', 'E', 'E', 'G', 'R', 'O', 'F', 'S', 'K', 'E', 'E', 'G')
printing elements between range 4-9:
('S', 'F', 'O', 'R', 'G')

DELETING A TUPLE
Tuples are immutable and hence they do not allow deletion of a part of it. The entire tuple get deleted by the use of del() method

|SHELL|
tupleone=tuple('GEEKSFORGEEKS')
del(tupleone)
print(tupleone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
Traceback (most recent call last):
  File "C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py", line 3, in <module>
    print(tupleone)
NameError: name 'tupleone' is not defined

Process finished with exit code 1

BUILT-IN METHODS
' index() ' | find in the tuple and returns the index of the given value where it's available
' count() ' | returns the frequency of occurrence of a specified value

BUILT-IN FUNCTIONS
' all() '       | returns true if all element are true or if tuple is empty
' any() '       | return true if any element of the tuple is true. If tuple is empty, return false
' len() '       | return length of the tuple or size of the tuple
' enumerate() ' | returns enumerate object of tuple
' max() '       | return maximum element of given tuple
' min() '       | return minimum element of a given tuple
' sum() '       | sums up the numbers in the tuple
' sorted() '    | input elements in the tuple and return a new sorted list
' tuple() '     | convert an iterable to a tuple

PYTHON DICTIONARY
Dictionary in python is a collection of keys values, used to store data values like a map, which, unlike other data types which hold only a single value as an element

EXAMPLES OF DICTIONARY IN PYTHON
Dictionary holds ' key:value ' pairs. Key-Value is provided in the dictionary to make it more optimized.

|SHELL|
dictone = {1: 'geeks', 2: 'for',3: 'geeks'}
print(dictone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
{1: 'geeks', 2: 'for', 3: 'geeks'}

Process finished with exit code 0

CREATING A DICTIONARY
In python, a dictionary can be created by placing a sequence of elements within curly{} braces, separated by comma. Dictionary holds pairs of values, one being the Key and the other corresponding pair element being its key:value. Values in a dictionary can be of any data type and can be duplicated, whereas keys can't be repeated and must be immutable. Dictionary keys are case sensitive, the same name but different cases of Key will be treated distinctly.

|SHELL|
dictone = {1: 'geeks', 2: 'for',3: 'geeks'}
print('dictionary with the use of integer keys: ')
print(dictone)

dicttwo = {'Name': 'geeks',1: [1,2,3,4]}
print('\ndictionary with the use of mixed keys: ')
print(dicttwo)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
dictionary with the use of integer keys:
{1: 'geeks', 2: 'for', 3: 'geeks'}

dictionary with the use of mixed keys:
{'Name': 'geeks', 1: [1, 2, 3, 4]}

Process finished with exit code 0

Dictionary can also be create by the built-in function dict(). An empty dictionary can be created by just placing to curly braces{}

|SHELL|
dictone = {1: 'geeks', 2: 'for',3: 'geeks'}
print('dictionary with the use of integer keys: ')
print(dictone)

dicttwo = {'Name': 'geeks',1: [1,2,3,4]}
print('\ndictionary with the use of mixed keys: ')
print(dicttwo)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
dictionary with the use of integer keys:
{1: 'geeks', 2: 'for', 3: 'geeks'}

dictionary with the use of mixed keys:
{'Name': 'geeks', 1: [1, 2, 3, 4]}

Process finished with exit code 0

NESTED DICTIONARY


        keys
          1____________________________geeks

          2______________________________for

          3_________[nested key]
                    |          |
                    |     A____|______welcome
                    |          |
                    |     B____|___________to
                    |          |
                    |     C____|________geeks
                    |__________|

|SHELL|
dictone = {1:'geeks',2:'for',
           3:{'A':'Welcome','B':'to','C': 'Geeks'}}
print(dictone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_1.py
{1: 'geeks', 2: 'for', 3: {'A': 'Welcome', 'B': 'to', 'C': 'Geeks'}}

Process finished with exit code 0

ADDING ELEMENTS TO A DICTIONARY - CREATING A DATABASE - SET KEY
Addition of elements can be done in multiple ways. One value at a time can be added to a dictionary by defining value alone with the key. Updating an existing value in a Dictionary can be done by using the built-in update() method. Nested key values can also be added to an existing Dictionary. While adding a value, if the key value already exists, the value get updated otherwise a new Key with the value is added to the dictionary.

|SHELL|
dictone={}
print('EMPTY DICTIONARY: ')
print(dictone)

dictone[0] = 'geeks'
dictone[1] = 'for'
dictone[2] = 1
print('ADDING THREE ELEMENTS: ')
print(dictone)

dictone['valueset'] = 2,3,4
print('\nAFTER ADDING THREE ELEMENTS: \nin this one you are adding a list as a key and declaring the values by setting the key equal to other elements, \nthis is then added to the list as a " key:value " pair: \n')
print(dictone)

dictone[2]='welcome'
print('\nUPDATED KEY VALUE:\n you can declare a new value for a specified key with this code: \n')
print(dictone)

dictone[5]={'nested':{'1':'life','2':'geeks'}}
print('\nADDING NESTED KEY: ')
print(dictone)

|TERMINAL|
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_2.py
EMPTY DICTIONARY:
{}
ADDING THREE ELEMENTS:
{0: 'geeks', 1: 'for', 2: 1}

AFTER ADDING THREE ELEMENTS:
in this one you are adding a list as a key and declaring the values by setting the key equal to other elements,
this is then added to the list as a " key:value " pair:

{0: 'geeks', 1: 'for', 2: 1, 'valueset': (2, 3, 4)}

UPDATED KEY VALUE:
 you can declare a new value for a specified key with this code:

{0: 'geeks', 1: 'for', 2: 'welcome', 'valueset': (2, 3, 4)}

ADDING NESTED KEY:
{0: 'geeks', 1: 'for', 2: 'welcome', 'valueset': (2, 3, 4), 5: {'nested': {'1': 'life', '2': 'geeks'}}}

Process finished with exit code 0

ACCESSING ELEMENTS OF A DICTIONARY
In order to access the items of a dictionary refer to its key name. Key can be used inside square brackets.

SHELL___
dictone={1: 'geeks','name': 'for',3: 'geeks'}
print('accessing an element using key: ')
print(dictone['name'])

print('accessing a element using a key')
print(dictone[1])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
accessing an element using key:
for
accessing a element using a key
geeks

Process finished with exit code 0

There is also a method called get() that will also help in accessing the element from a dictionary. This method accepts key as argument and returns the value

ACCESSING DICTIONARY USING GET
SHELL___
dictone= {1:'geeks','name':'For',3:'Geeks'}

print('accessing a element using get')
print(dictone.get(3))

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
accessing a element using get
Geeks

Process finished with exit code 0

ACCESSING AN ELEMENT OF A NESTED DICTIONARY
In order to access the value of any key in the nested dictionary, use indexing [] syntax.

SHELL___
dictone={'dictoneone':{1: 'geeks'},'dicttwo':{'name':'for'}}

print(dictone['dictoneone'])
print(dictone['dictoneone'][1])
print(dictone['dicttwo']['name'])


overall={'smaller':{1:'\nsmallerone'},'bigger':{2:'biggerone'}}
print(overall['smaller'][1])

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
{1: 'geeks'}
geeks
for

smallerone

Process finished with exit code 0

DELETING ELEMENTS USING DEL KEYWORD
The items of the dictionary can be deleted by using the del keyword as given below

SHELL___
dictone={'dictoneone':{1: 'geeks'},'dicttwo':{'name':'for'}}

print('\ndictionary = ')
print(dictone)

del(dictone['dictoneone'])
print('\ndata after the deletion of Dictionary part=')
print(dictone)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
dictionary =
{'dictoneone': {1: 'geeks'}, 'dicttwo': {'name': 'for'}}

data after the deletion of Dictionary part=
{'dicttwo': {'name': 'for'}}

Process finished with exit code 0

DICTIONARY METHODS
dict.clear()                        | Removed all elements from the dictionary
dict.copy()                         | Returns a copy of the dictionary
dict.get(key,default='None')        | Returns the values of the specified key
dict.items()                        | Returns a list containing a tuple for each key value pair
dict.key()                          | Returns a list containing dictionary's keys
dict.update(dict2)                  | Updates dictionary with specified key-value pairs
dict.values()                       | Returns a list of all the values of dictionary
pop()                               | Remove the element with specified key
popItem()                           | Removes the last inserted key-value pair
dict.setdefault(key,default='None') | Set the key to the default value if the key is not specified in the dictionary
dict.has_key(key)                   | Returns true if the dictionary contains the specified key
dict.get(key, default='None)        | Used to get the value specified for the passed key

SHELL___
dictone={1:'python',2:'java',3:'ruby',4:'scala'}

dict2=dictone.copy()
print('\ndictone was copied to dictionary 2 with " <dictionaryname>.copy() ", this is dictone: ')
print(dictone)
print('\nthis is dict2: ')
print(dict2)

dictone.clear()
print('\nclearing a dictionary with " <dictionaryname>.clear() " here is the result for " dictone ": ')
print(dictone)

print('\nthis will pull the first key labelled " 1 " from " dict2 ", the copy of " dictone ": ')
print(dict2.get(1))

print('\n"<dictionaryname>.items() " will print everything that is not a key from the list:')
print(dict2.items())

print('\nHere are the keys using " <dictionaryname>.keys() "')
print(dict2.keys())

print('\nHere we are using " <dictionaryname>.pop() " to remove the 4th key:value set from the list: ')
dict2.pop(4)
print(dict2)

print('\nHere we are using " <dictionaryname>.popitem() " to remove the last item from the list')
dict2.popitem()
print(dict2)

print('\nHere we will update a key:value pair but we have to enter the pair in brackets for it to work: ')
dict2.update({3:"scalea"})
print(dict2)

print('\nHere we will use the "<dictionaryname>.values()" method to pull the values: ')
print(dict2.values())

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py

dictone was copied to dictionary 2 with " <dictionaryname>.copy() ", this is dictone:
{1: 'python', 2: 'java', 3: 'ruby', 4: 'scala'}

this is dict2:
{1: 'python', 2: 'java', 3: 'ruby', 4: 'scala'}

clearing a dictionary with " <dictionaryname>.clear() " here is the result for " dictone ":
{}

this will pull the first key labelled " 1 " from " dict2 ", the copy of " dictone ":
python

"<dictionaryname>.items() " will print everything that is not a key from the list:
dict_items([(1, 'python'), (2, 'java'), (3, 'ruby'), (4, 'scala')])

Here are the keys using " <dictionaryname>.keys() "
dict_keys([1, 2, 3, 4])

Here we are using " <dictionaryname>.pop() " to remove the 4th key:value set from the list:
{1: 'python', 2: 'java', 3: 'ruby'}

Here we are using " <dictionaryname>.popitem() " to remove the last item from the list
{1: 'python', 2: 'java'}

Here we will update a key:value pair but we have to enter the pair in brackets for it to work:
{1: 'python', 2: 'java', 3: 'scalea'}

Here we will use the "<dictionaryname>.values()" method to pull the values:
dict_values(['python', 'java', 'scalea'])

Process finished with exit code 0

PYTHON FUNCTIONS
PYTHON FUNCTIONS is a block of statements that return the specific task. The idea is to put some commonly or repeatedly done tasks together and make a function so that instead of writing the same code again and again for different inputs, we can do the function calls to reuse code contained in it over and over again. Some benefits of using functions:
    - Increased code readability
    - Increase code re-usability

PYTHON FUNCTION DECLARATION
The syntax to declare a function is:


        keyword     function name    parameter
           |             |               |
          def       function_name ( parameters )
            #statement --------------------------> body of statement
            return expression
               |________|
                   |
            function return

TYPES OF FUNCTIONS IN PYTHON
There are mainly two types of functions in Python:
    - Built-in Library functions: These are standard functions in Python that are available to use
    - User-defined functions: We can create our own functions base don our requirements

CREATING A FUNCTION IN PYTHON
We can create a Python function using the " def " keyword.

SHELL___
def fun():
    print("welcome to GFG")

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py

Process finished with exit code 0

CALLING A PYTHON FUNCTION
After creating a function we can call it by using the name of the function followed by parenthesis containing parameters of that particular function

SHELL___
def fun():
    print("welcome to GFG")
fun()

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
welcome to GFG

Process finished with exit code 0

PYTHON FUNCTION WITH PARAMETERS
If you have experience in C/C++ or Java then you must be thinking about the return type of the function and data type of arguments. That is possible in Python as well.

DEFINING AND CALLING A FUNCTION WITH PARAMETERS
SHELL___
 def function_name(parameter: data_type) -> return_type:
    """Docstring"""
    # body of the function
    return expression

The following example uses arguments and parameters that you will learn later in this article so you can come back to it again if not understood
SHELL___
def add(num1: int,num2: int) -> int:
    num3 = num1 + num2

    return num3

num1,num2=5,15
ans = add(num1, num2)
print(f'the addition of {num1} and {num2} results {ans}.')

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_3.py
the addition of 5 and 15 results 20.

Process finished with exit code 0

The following examples are defined using syntax 1, try to convert them in syntax 2 for practice

SHELL___
def is_prime(n):
    if n in [2,3]:
        return True
    if (n == 1) or (n % 2 == 0):
        return False
    r = 3
    while r * r <= n:
        if n % r == 0:
            return False
        r += 2
    return True
print(is_prime(78), is_prime(79))

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_7.py
False True

Process finished with exit code 0

PYTHON FUNCTION ARGUMENTS
Arguments are the values passed inside the parenthesis of the function. A function can have any number of arguments separated by a comma. In this example, we will create a simple function to check whether the number passed as an argument to the function is even or odd.

SHELL___
def evenOdd(x):
    if (x % 2 == 0):
        print('even')
    else:
        print('odd')
evenOdd(2)
evenOdd(3)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_8.py
even
odd

Process finished with exit code 0

TYPES OF PYTHON FUNCTIONS ARGUMENTS
Python supports various types of arguments that can be passed at the time of the function call. In python, we have the following 4 types of function arguments. 1. ) DEFAULT ARGUMENT, 2. ) KEYWORD ARGUMENT, 3. ) POSITIONAL ARGUMENT, 4. ) ARBITRARY ARGUMENT

DEFAULT ARGUMENTS
A default argument is a parameter that assumes a default values if a value is not provided in the function call for that argument. The following example illustrates default argument. The following example illustrates default arguments:

SHELL___
def myFun(x,y=50):
    print('x: ',x)
    print('y: ',y)

myFun(10)

TERMINAL
C:\Users\KhoriWilson\AppData\Local\Programs\Python\Python39\python.exe C:\Users\KhoriWilson\AppData\Roaming\JetBrains\PyCharmCE2022.3\scratches\scratch_8.py
x:  10
y:  50

Process finished with exit code 0

Like C++ default arguments, any number of arguments in a function can have a default value. But once we have a default argument, all the arguments to its right must also have default values. So what I think it's saying is if you put a value in the function for a certain variable then when you call the function you only need to enter a value for the variable that was not given a value in the function and from there the called function will fill in the default value for a given variable and enter the value you specified in the call as the value of the unspecified variable.

KEYWORD ARGUMENTS
The idea is to allow the called to specify the argument name with values so that the called does not need to  remember the order of parameters.


